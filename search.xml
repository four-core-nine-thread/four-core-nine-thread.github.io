<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>__str__与__repr__区别</title>
      <link href="/2020/02/17/str-%E4%B8%8E-repr-%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/02/17/str-%E4%B8%8E-repr-%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>首先通过代码来对比一下<strong> str</strong> 和 <strong> repr</strong></p><p>只存在<strong> str</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayTest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'output_by_str'</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = DisplayTest()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test</span><br><span class="line">&lt;DisplayTest object at <span class="number">0x000002A101128940</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(test)</span><br><span class="line">output_by_str</span><br></pre></td></tr></table></figure><p>只存在<strong> repr</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayTest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'output_by_repr'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = DisplayTest()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test</span><br><span class="line">output_by_repr</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(test)</span><br><span class="line">output_by_repr</span><br></pre></td></tr></table></figure><p>同时存在<strong> str</strong> 和<strong> repr</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayTest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'output_by_str'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'output_by_repr'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = DisplayTest()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test</span><br><span class="line">output_by_repr</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(test)</span><br><span class="line">output_by_str</span><br></pre></td></tr></table></figure><p>从以上代码中可以看出，在控制台输出对象时会调用<strong> repr</strong> 方法，在使用print进行输出打印时会优先调用 <strong> str</strong> 方法，如果没有 <strong> str</strong> 方法，就会去调用 <strong> repr</strong> 方法。</p><p>如果在自定义类中没有重构str,repr方法，就会使用object基类中str,repr方法，输出对象一些地址相关的信息如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;DisplayTest object at <span class="number">0x000002A101128940</span>&gt;</span><br></pre></td></tr></table></figure><p>对于这两种方法，就像网上所说的那样，<strong> str</strong> 是面向用户，<strong> repr</strong> 是面向程序员的，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = <span class="string">'你好'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test</span><br><span class="line"><span class="string">'你好'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(test)</span><br><span class="line">你好</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetima</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now()</span><br><span class="line">datetime.datetime(<span class="number">2020</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="number">23</span>, <span class="number">48</span>, <span class="number">37</span>, <span class="number">449751</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.datetime.now())</span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-17</span> <span class="number">23</span>:<span class="number">48</span>:<span class="number">47.938524</span></span><br></pre></td></tr></table></figure><p>print输出的内容，更直观更容易理解一些，而直接使用终端输出的内容，让程序员更方便处理一些。</p><p>还需要注意的一点是，将对象放入容器中时，就算重构了 <strong> str</strong> 方法，进行print也是不会生效的，容器会使用 <strong> repr</strong> 中的返回值，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayTest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'output_by_str'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_1 = DisplayTest()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_2 = DisplayTest()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([test1, test2])</span><br><span class="line">[&lt;DisplayTest object at <span class="number">0x000002A100BCA588</span>&gt;, &lt;DisplayTest object at <span class="number">0x000002A100EFE630</span>&gt;]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayTest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'output_by_repr'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_1 = DisplayTest()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_2 = DisplayTest()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([test1, test2])</span><br><span class="line">[output_by_repr, output_by_repr]</span><br></pre></td></tr></table></figure><p>大部分的内建函数都会通过str, repr来输出实质相同但显示不同的值，或许这是作者想让代码更加pythonic吧，为我们提供一种设计代码的标准。</p><p>对于我自己来说，我更愿意在自定义类中去只设定一个<strong> repr</strong> ，因为它能同时兼顾终端输出和print输出，就像汽车的远光灯，同样具备近光灯的效果，但更远更亮。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java连接数据库---JDBC</title>
      <link href="/2018/02/03/Java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93-JDBC/"/>
      <url>/2018/02/03/Java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93-JDBC/</url>
      <content type="html"><![CDATA[<h3 id="JDBC简介和作用"><a href="#JDBC简介和作用" class="headerlink" title="JDBC简介和作用"></a>JDBC简介和作用</h3><p>JDBC(Java Database Connectivity),中文名为java数据库连接，是SUN公司提供的使用Java访问数据库的应用程序接口，让程序员可以通过Java来进行数据库操作，现在的JDBC可以在Oracle官网进行下载。Python中像mysqldb,pymysql也是实现了PEP提供的数据库访问规范，只是在使用时简化了过程，没有像JDBC那种通过反射来注册驱动。</p><h3 id="使用JDBC来操作Mysql数据库"><a href="#使用JDBC来操作Mysql数据库" class="headerlink" title="使用JDBC来操作Mysql数据库"></a>使用JDBC来操作Mysql数据库</h3><p>先将JDBC进行封装，只对外提供获取数据库连接对象和关闭数据库连接的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用静态代码块在字节码文件加载时运行一次，对驱动，用户信息等进行初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties(); <span class="comment">// 这里通过双列集合来加载数据库配置信息</span></span><br><span class="line">            properties.load(demo1.class.getClassLoader().getResourceAsStream(<span class="string">"JDBC.properties"</span>));</span><br><span class="line"></span><br><span class="line">            driver= properties.getProperty(<span class="string">"driver"</span>);</span><br><span class="line">            url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">            username = properties.getProperty(<span class="string">"username"</span>);</span><br><span class="line">            password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">            Class.forName(driver); <span class="comment">// 注册JDBC驱动</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为调用者提供数据库连接对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用重载来对不同情况的连接方式进行关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, PreparedStatement ps, ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        close(conn, ps, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(PreparedStatement ps, ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        close(<span class="keyword">null</span>, ps, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span>  SQLException</span>&#123;</span><br><span class="line">        close(<span class="keyword">null</span>, ps, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用封装好的JDBC工具类来操作数据库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection conn = JDBCUtil.getConnection(); <span class="comment">// 通过工具类获取连接</span></span><br><span class="line"></span><br><span class="line">        PreparedStatement ps = conn.prepareStatement(<span class="string">"SELECT * FROM TEACHER WHERE TID = ?"</span>); <span class="comment">// 获取数据库执行对象， 通过?占位符的方式可以有效防止SQL注入</span></span><br><span class="line">        ps.setString(<span class="number">1</span>, <span class="string">"04"</span>);</span><br><span class="line"></span><br><span class="line">        ResultSet rs = ps.executeQuery(); <span class="comment">// 执行查询语句，返回一个结果集，操作方式类似于迭代器获取数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line"></span><br><span class="line">            String tid = rs.getString(<span class="string">"tid"</span>);</span><br><span class="line">            String tname = rs.getString(<span class="string">"tname"</span>);</span><br><span class="line">            System.out.println(tid + <span class="string">"..."</span> + tname);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JDBCUtil.close(ps, rs);</span><br><span class="line"></span><br><span class="line">        PreparedStatement ps1 = conn.prepareStatement(<span class="string">"UPDATE TEACHER SET TNAME = ? WHERE TID = ?"</span>);</span><br><span class="line">        ps1.setString(<span class="number">1</span>, <span class="string">"jack"</span>);</span><br><span class="line">        ps1.setString(<span class="number">2</span>, <span class="string">"04"</span>);</span><br><span class="line">        <span class="keyword">int</span> affectedRows = ps1.executeUpdate(); <span class="comment">// 执行更新语句，返回的是受影响行数</span></span><br><span class="line">        System.out.println(affectedRows);</span><br><span class="line"></span><br><span class="line">        JDBCUtil.close(conn, ps, rs);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java,数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中xml解析---jsoup</title>
      <link href="/2018/01/30/Java%E4%B8%ADxml%E8%A7%A3%E6%9E%90-jsoup/"/>
      <url>/2018/01/30/Java%E4%B8%ADxml%E8%A7%A3%E6%9E%90-jsoup/</url>
      <content type="html"><![CDATA[<h3 id="使用jsoup对xml文件进行解析"><a href="#使用jsoup对xml文件进行解析" class="headerlink" title="使用jsoup对xml文件进行解析"></a>使用jsoup对xml文件进行解析</h3><p>jsoup主要是用于对html进行解析，但是xml和html在结构上大体是一样的，所以也能用于对xml解析且在获取元素时是不区分大小写的，这一点和dom4j是有区别的.jsoup同样支持XPATH的方式来获取节点，并且还提供了选择器的方式来对节点进行选择。</p><p>jsoup使用普通方式来解析xml：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// parse()是个重载方法，提供了多种获取Document对象的方式</span></span><br><span class="line">        Document document = Jsoup.parse(demo.class.getClassLoader().getResourceAsStream(<span class="string">"JDBC.xml"</span>), <span class="string">"UTF-8"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="comment">// Document document = Jsoup.parse(new File(demo.class.getClassLoader().getResource("JDBC.xml")), "UTF-8");</span></span><br><span class="line">        </span><br><span class="line">        Element element = document.getElementById(<span class="string">"mysql"</span>); <span class="comment">// 类似于JS，通过id获取单个对象</span></span><br><span class="line">        <span class="keyword">for</span>(Element e : element.children())&#123;</span><br><span class="line">            System.out.println(e.tagName + <span class="string">"..."</span> + e.text());</span><br><span class="line">        &#125; <span class="comment">// 遍历节点下的所有子节点，并打印标签名和内容</span></span><br><span class="line">        </span><br><span class="line">        Elements elements = document.getElementByTag(<span class="string">"database"</span>); <span class="comment">// 通过标签名获取多个对象，Elements继承ArrayList</span></span><br><span class="line">        <span class="keyword">for</span>(Element e : elements)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Element e1 : e.children())&#123;</span><br><span class="line">                System.out.println(e1.tagName + <span class="string">"..."</span> + e.text());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 遍历列表中的所有元素，再获取这些元素下的所有子标签及其内容</span></span><br><span class="line">        </span><br><span class="line">        Elements elements1 = document.getElementByAttributeValue(<span class="string">"id"</span>, <span class="string">"mysql"</span>); <span class="comment">// 通过属性来获取多个对象</span></span><br><span class="line">        System.out.println(elements1.get(<span class="number">0</span>)) <span class="comment">// 获取列表中的第一个元素，打印出的是该标签的整个XML结构</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jsoup使用选择器方式来解析xml:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Document document = Jsoup.parse(demo.class.getClassLoader().getResourceAsStream(<span class="string">"JDBC.xml"</span>), <span class="string">"UTF-8"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        Elements elements = document.select(<span class="string">"#mysql"</span>); <span class="comment">// id选择器</span></span><br><span class="line">        Elements elements1 = document.select(<span class="string">".mysql"</span>); <span class="comment">// 类选择器</span></span><br><span class="line">        Elements elements2 = document.select(<span class="string">"database"</span>); <span class="comment">// 标签选择器</span></span><br><span class="line">        Elements elements3 = document.select(<span class="string">"driver[name='driver']"</span>); <span class="comment">// 标签 + 属性选择器</span></span><br><span class="line">        Elements elements4 = document.select(<span class="string">"[name]"</span>); <span class="comment">// 属性选择器</span></span><br><span class="line">        <span class="keyword">for</span> (Element e: elements4)&#123;</span><br><span class="line">            System.out.println(e.tagName() + <span class="string">"..."</span> + e.text());</span><br><span class="line">        &#125; <span class="comment">// 打印获取到的所有的标签及其内容</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jsoup使用XPATH方式来解析xml,需要注意的是获取根目录不使用/,获取指定标签都是使用//:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, XpathSyntaxErrorException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Document document = Jsoup.parse(demo.class.getClassLoader().getResourceAsStream(<span class="string">"JDBC.xml"</span>), <span class="string">"UTF-8"</span>, <span class="string">""</span>);</span><br><span class="line">        </span><br><span class="line">        JXDocument jxDocument = <span class="keyword">new</span> JXDocument(document); <span class="comment">// JXDocument对Document对象进行封装使其具有XPATH的功能</span></span><br><span class="line">        </span><br><span class="line">        List&lt;JXNode&gt; jxNodes = jxDocument.selN(<span class="string">"//database"</span>); <span class="comment">// 获取所有的database标签，返回值是一个列表</span></span><br><span class="line">        <span class="keyword">for</span> (JXNode j:jxNodes)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Element e:j.getElement().children())&#123;</span><br><span class="line">                System.out.println(e.tagName() + <span class="string">"..."</span> + e.text());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 获取标签内容时，需要将JXNode对象转换为Element对象</span></span><br><span class="line">        </span><br><span class="line">        List&lt;JXNode&gt; jxNodes1 = jxDocument.selN(<span class="string">"//database[@id='mysql']"</span>); <span class="comment">// 增加筛选条件</span></span><br><span class="line">        <span class="keyword">for</span> (JXNode j:jxNodes1)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Element e:j.getElement().children())&#123;</span><br><span class="line">                System.out.println(e.tagName() + <span class="string">"..."</span> + e.text());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        JXNode jxNode = jxDocument.selNOne(<span class="string">"//database[@id='mysql']"</span>); <span class="comment">// 就算有多个标签，也只返回第一个标签</span></span><br><span class="line">        <span class="keyword">for</span> (Element e:jxNode.getElement().children())&#123;</span><br><span class="line">            System.out.println(e.tagName() + <span class="string">"..."</span> + e.text());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中xml解析---dom4j</title>
      <link href="/2018/01/29/Java%E4%B8%ADxml%E8%A7%A3%E6%9E%90-dom4j/"/>
      <url>/2018/01/29/Java%E4%B8%ADxml%E8%A7%A3%E6%9E%90-dom4j/</url>
      <content type="html"><![CDATA[<h3 id="xml的解析方式"><a href="#xml的解析方式" class="headerlink" title="xml的解析方式"></a>xml的解析方式</h3><p> 解析方式为两种:</p><ul><li><p>DOM(Document Object Model)解析：将整个xml文件加载到内存，形成一个DOM树</p><ul><li>优点：能获取到整个DOM树的完整信息，通过document对象来对DOM树进行CRUD操作</li><li>缺点：由于是直接加载整个xml文件，当形成的DOM树太大时，会占用较多的内存资源</li></ul></li><li><p>SAX(Simple API For Xml)解析：对xml进行逐行解析，逐行加载，需要哪行就加载哪行</p><ul><li>优点：逐行加载，不太占用内存资源</li><li>缺点：无法获取整个DOM树对象，只能对xml数据进行查询，不能增删</li></ul></li></ul><h3 id="xml常用的解析器"><a href="#xml常用的解析器" class="headerlink" title="xml常用的解析器"></a>xml常用的解析器</h3><p>jaxp：是SUN公司提供的xml解析器，支持dom和sax这两种方式的解析</p><p>dom4j：是开源组织提供的xml解析器，性能是优于SUN公司提供的解析器的, 基于dom和sax这两种方式的综合解析方式</p><p>jsoup：主要是用来解析html的，但是由于html和xml的结构是一样的，所以也可以用来解析xml</p><h3 id="使用demo4j对xml文件进行CRUD"><a href="#使用demo4j对xml文件进行CRUD" class="headerlink" title="使用demo4j对xml文件进行CRUD"></a>使用demo4j对xml文件进行CRUD</h3><p>首先获取根标签对象，对DOM树操作是基于root来进行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Document document;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Element root;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="comment">// read()是个重载方法， 可以通过多种方式来获取Document对象</span></span><br><span class="line">        <span class="comment">// document = saxReader.read(demo.class.getClassLoader().getResourceAsStream("JDBC.xml"));</span></span><br><span class="line">        document = saxReader.read(<span class="keyword">new</span> File(demo.class.getClassLoader().getResource(<span class="string">"JDBC.xml"</span>).getPath()));</span><br><span class="line">        root = document.getRootElement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取JDBC.xml中的数据库信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, String&gt; <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法一</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    List&lt;Element&gt; elementList = root.elements(); // 获取根标签下的所有子标签，返回值为一个列表</span></span><br><span class="line"><span class="comment">    for(Element e:elementList)&#123;</span></span><br><span class="line"><span class="comment">        if(e.attributeValue("id").equals("mysql"))&#123;</span></span><br><span class="line"><span class="comment">            for(Element e1:e.elements())&#123;</span></span><br><span class="line"><span class="comment">                hashMap.put(e1.getName(), e1.getText());</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125; // 获取子标签中所有的标签信息，将标签名和标签内容组成键值对放入双列集合中</span></span><br><span class="line"><span class="comment">    return hashMap;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法二</span></span><br><span class="line">    Element element = root.elementByID(<span class="string">"mysql"</span>); <span class="comment">// 获取指定id的子标签，返回值为标签对象</span></span><br><span class="line">    <span class="keyword">for</span>(Element e:element.elements())&#123;</span><br><span class="line">        hashMap.put(e.getName(), e.getText());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对xml文件进行增删改时，修改的是加载在内存中DOM树对象，在修改完成后，还要将DOM树对象写入到xml文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveXML</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    OutputStream os = <span class="keyword">new</span> FileOutputStream(path); <span class="comment">// 创建字节输出流对象，也可以使用字符输出流</span></span><br><span class="line">    OutputFormat format = OutputFormat.creatPrettyPrint(); <span class="comment">// 创建输出格式化对象</span></span><br><span class="line">    </span><br><span class="line">    XMLWriter writer = <span class="keyword">new</span> XMLWriter(os, format); <span class="comment">// 创建XML字符输出流对象</span></span><br><span class="line">    writer.write(document); <span class="comment">// 将被修改的DMO树对象写入的指定文件中</span></span><br><span class="line">    writer.close();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为JDBC.xml添加一个数据库信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Element element = root.addElement(<span class="string">"database"</span>); <span class="comment">// 在根标签下添加一个子标签</span></span><br><span class="line">    element.setAttributeValue(<span class="string">"ID"</span>, <span class="string">"oracle"</span>); <span class="comment">// 为该子标签添加属性</span></span><br><span class="line">    </span><br><span class="line">    Element driverElement = element.addElement(<span class="string">"driver"</span>); <span class="comment">// 在子标签下再创建子标签，并添加文本内容</span></span><br><span class="line">    driverElement.setText(<span class="string">"com.oracle.jdbc.driver"</span>);</span><br><span class="line">    </span><br><span class="line">    Element urlElement = element.addElement(<span class="string">"url"</span>);</span><br><span class="line">    urlElement.setText(<span class="string">"jdbc:oracle://localhost:1521/testDb"</span>);</span><br><span class="line">    </span><br><span class="line">    Element userElement = element.addElement(<span class="string">"user"</span>);</span><br><span class="line">    userElement.setText(<span class="string">"root"</span>);</span><br><span class="line">    </span><br><span class="line">    Element pwdElement = element.addElement(<span class="string">"pwd"</span>);</span><br><span class="line">    pwdElement.setText(<span class="string">"root"</span>);</span><br><span class="line">    </span><br><span class="line">    saveXML(demo.class.getClassLoader().getResource(<span class="string">"JDBC.xml"</span>).getPath()); <span class="comment">// 将原XML覆盖</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改JDBC.xml中的数据库信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Element element = root.elementByID(<span class="string">"oracle"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Element e:element.elements())&#123;</span><br><span class="line">        <span class="keyword">if</span>(e.getName().equals(<span class="string">"pwd"</span>))&#123;</span><br><span class="line">            e.setAttributeValue(<span class="string">"name"</span>, <span class="string">"pwd"</span>);</span><br><span class="line">            e.setText(<span class="string">"123456"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    saveXML(demo.class.getClassLoader().getResource(<span class="string">"JDBC.xml"</span>).getPath());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除JDBC.xml中的数据信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;Element&gt; elementsList = root.elements();</span><br><span class="line">    <span class="keyword">for</span>(Element e:elementList)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.attributeValue(<span class="string">"ID"</span>).equals(<span class="string">"oracle"</span>))&#123;</span><br><span class="line">                root.remove(e);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="comment">// 将整个子标签全部删除</span></span><br><span class="line">    </span><br><span class="line">    saveXML(demo.class.getClassLoader().getResource(<span class="string">"JDBC.xml"</span>).getPath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过XPATH的方式来获取标签对象"><a href="#通过XPATH的方式来获取标签对象" class="headerlink" title="通过XPATH的方式来获取标签对象"></a>通过XPATH的方式来获取标签对象</h3><p>上面是通过根标签来获取DOM树中的node节点，dom4j还提供了以XPATH的方式来获取指定标签，这种方式更为灵活：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        Document document = saxReader.read(demo.class.getClassLoader().getResourceAsStream(<span class="string">"JDBC.xml"</span>)); </span><br><span class="line">        </span><br><span class="line">        List&lt;Node&gt; nodesList = document.selectNodes(<span class="string">"/databases"</span>); <span class="comment">// 获取根标签</span></span><br><span class="line">        List&lt;Node&gt; nodesList1 = document.selectNodes(<span class="string">"//database"</span>); <span class="comment">// 获取所有的database标签</span></span><br><span class="line">        List&lt;Node&gt; nodesList2 = document.selectNodes(<span class="string">"//database[@ID='mysql']"</span>); <span class="comment">//获取所有ID为Mysql的database标签</span></span><br><span class="line">        Node node = document.selectSingleNode(<span class="string">"//user[@name='username']"</span>); <span class="comment">//获取name为username的一个user标签</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(node.getName()); <span class="comment">// 打印节点的标签名</span></span><br><span class="line">        System.out.println(node.getText()); <span class="comment">// 打印节点的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu远程连接MySQL(connection refused)解决方法</title>
      <link href="/2018/01/27/Ubuntu%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5MySQL-connection-refused-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2018/01/27/Ubuntu%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5MySQL-connection-refused-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>连接阿里云数据库的时候.端口,正常配置都完成的情况下,依然显示connection refused.</p><p>解决这个问题需要进入vim /etc/mysql/mysql.conf.d/mysqld.conf中将</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bind-address = 127.0.0.1</span></span><br></pre></td></tr></table></figure><p>这句话注释掉就可以解决这个问题</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TDD流程</title>
      <link href="/2018/01/25/TDD%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/01/25/TDD%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>在一个项目中使用到TDD来完成测试首先需要知道该干什么,如何去干,查询资料归纳了一下TDD工作的整个流程,因为没有找到XMind中的流程图,所以只好手动画了.</p><p>TDD的总体流程:</p><p><img src=".\tdd.jpg" alt=""></p><p>包含功能测试和单元测试的TDD流程:</p><p><img src=".\tdd2.jpg" alt=""></p><p>功能测试是应用是否能正常运行的最终评判,而单元测试只是整个开发过程中的一个辅助工具,不难看出,面对用户的FT是衡量一个应用是否被用户正常使用的判断标准.</p>]]></content>
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试,Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu更新pip后无法导入main解决方法</title>
      <link href="/2018/01/22/Ubuntu%E6%9B%B4%E6%96%B0pip%E5%90%8E%E6%97%A0%E6%B3%95%E5%AF%BC%E5%85%A5main%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2018/01/22/Ubuntu%E6%9B%B4%E6%96%B0pip%E5%90%8E%E6%97%A0%E6%B3%95%E5%AF%BC%E5%85%A5main%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>使用阿里云的Ubuntu镜像之后,进行pip的更新,更新完成之后进行pip安装模块会出现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: cannot <span class="keyword">import</span> name main</span><br></pre></td></tr></table></figure><p>这个问题需要修改/usr/bin/pip文件中,修改成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pip <span class="keyword">import</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    sys.exit(main())</span><br></pre></td></tr></table></figure><p>安装pip3的时候好像也是这个问题,修改相应的配置文件就可以使用了</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编程就像从井里打水</title>
      <link href="/2018/01/20/%E7%BC%96%E7%A8%8B%E5%B0%B1%E5%83%8F%E4%BB%8E%E4%BA%95%E9%87%8C%E6%89%93%E6%B0%B4/"/>
      <url>/2018/01/20/%E7%BC%96%E7%A8%8B%E5%B0%B1%E5%83%8F%E4%BB%8E%E4%BA%95%E9%87%8C%E6%89%93%E6%B0%B4/</url>
      <content type="html"><![CDATA[<p>编程对每个人来说都不是一件容易的事,如果说成功源于一个人的努力和聪明才智,那像我这样不那么聪明的人,TDD就能助我一臂之力.</p><p>TDD的创始人Kent Beck打了个比方.试想从井里提一桶水,如果井不太深,而且桶不是很慢,提起来很容易,就算提满满的一桶水,刚开始也很容易,毕竟井并不深,但是如果井很深呢?我们能一次性把水给提上来吗?力气大的人或许可以,但是所有人都是大力士吗?TDD理念就好比是一个棘轮,使用它可以保存当前的进度,休息一会,而且能保证进度绝不会倒退,也并不需要我是大力士.</p><p>当然TDD的使用也是区别情况的,但大多数一个商业项目都是复杂的,并不都是像浅井那样一次性提满水,不过在一口浅井中使用棘轮就显的有点傻.</p>]]></content>
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试,Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初识TDD</title>
      <link href="/2018/01/15/%E5%88%9D%E8%AF%86TDD/"/>
      <url>/2018/01/15/%E5%88%9D%E8%AF%86TDD/</url>
      <content type="html"><![CDATA[<p>Python的魅力不仅在于简洁的语法和作为胶水一样和其他语言进行粘合,我最崇拜的是其几乎是无所不能的三方库,至少在我看来,拥有良好生态的python前途是一片光明的.</p><p>在工作大半年之后,也学习了Django,Flask这样主流的python框架,我开始思考接下来的时间里我需要去发展的方向,我很明确我的最终目标肯定是在程序员顶端的大数据和AI,但是目前的我来说,他们距离我太遥远,我连numpy,pandas都还一头雾水,更不说去完成数据的处理了.</p><p>最近和同事聊天说到测试这一块,我对于测试的理解仅仅限于手动去测试某些功能,就像工人测试一块遥控器会一个按钮一个按钮的按.我承认我负责的模块不是很难,很多问题都可以通过debug去解决为什么还需要测试这玩意呢?</p><p>同事给我看了曾经项目的一个业务,我看的不是很懂,所以应该是很复杂的,复杂到他说想要去修改一部分代码都很困难,开始巴拉巴拉说了一些使用TDD的好处.</p><p>他给我介绍到了TDD,也觉得往这方面发展也是对于写框架的一种提升,虽然当时我并不是很理解TDD的概念,但是明白最简单的一点,使用测试驱动开发就是需要’’测试,小幅改动,测试’直到代码完全正常,使用功能测试去模拟用户,使用单元测试来模拟程序员,使用是自动化测试来测试整个项目而不是在这儿点点链接,在输入框中输入点信息.</p><p>说到TDD肯定就会说到敏捷开发,因为他们是密不可分的,有时候我并不需要将产品的所有功能都实现才上线,就现在的环境,谁先推出项目谁先占领市场谁才会笑到最后.</p><p>这是我第一次认识到TDD,虽然肤浅,但是对于测试我有了重新的认识.</p>]]></content>
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试,Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flask与Django对比</title>
      <link href="/2018/01/07/Flask%E4%B8%8EDjango%E5%AF%B9%E6%AF%94/"/>
      <url>/2018/01/07/Flask%E4%B8%8EDjango%E5%AF%B9%E6%AF%94/</url>
      <content type="html"><![CDATA[<h3 id="Django"><a href="#Django" class="headerlink" title="Django:"></a>Django:</h3><p>我个人更喜欢使用Django,因为我能想到的,它基本都帮我完成了,它会告诉我需要在哪个文件中写什么,也会明确的告诉我在哪里出现了错误.</p><ol><li>Django体系庞大,自带功能完善的ORM和模板引擎,在灵活上和自由度上不够高,把我们的行动范围限制在了它准备好的框架中</li><li>使用Django开发小应用有一种使用Scapy去爬取小网站的感觉,大材小用.</li><li>Django与SQL耦合度过高,与NoSQL的搭配并不好.</li><li>Django适合企业级的网站开发:快速,安全,稳定</li><li>Django比Flask更成熟,完善,但是生态相对封闭</li><li>Django的官网比Flask好看太多.</li></ol><p>这些只是Django优点的一部分,百度上还有很多.</p><h3 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h3><p>第一次使用Flask时,我真的不知所措,我不知道在哪里需要干什么,文件到底放在哪里,代码应该放在哪个py文件中,我觉得大牛应该更喜欢Flask,因为它提供了一个自由发挥的场地,大牛们可以随意发挥不受拘束.</p><ol><li>Flask没有Django那么重,更为自由,灵活</li><li>很适合小型应用,开发大型应用时,需要开发者有较强的能力和经验</li><li>在性能方面都会比Django要好</li><li>与关系型数据库的匹配不弱于Django,但在NoSQL方面的匹配要强于Django</li></ol>]]></content>
      
      
        <tags>
            
            <tag> Flask, Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络体系结构</title>
      <link href="/2018/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2018/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">法律上的国际标准(由OSI制定)</th></tr></thead><tbody><tr><td style="text-align:center">应用层</td></tr><tr><td style="text-align:center">表示层</td></tr><tr><td style="text-align:center">会话层</td></tr><tr><td style="text-align:center">运输层</td></tr><tr><td style="text-align:center">网络层</td></tr><tr><td style="text-align:center">数据链路层</td></tr><tr><td style="text-align:center">物理层</td></tr></tbody></table><table><thead><tr><th style="text-align:center">事实上的国际标准</th></tr></thead><tbody><tr><td style="text-align:center">应用层</td></tr><tr><td style="text-align:center">运输层</td></tr><tr><td style="text-align:center">网际层</td></tr><tr><td style="text-align:center">网络接口层</td></tr></tbody></table><p>因为各种原因,由OSI制定的法律标准并没有被使用,而是使用较早出现的四层体系结构.</p><p>应用层和运输层是开发者面对最多的层次,在应用层中我们主要关心的是应用与用户之间交互,而运输层我们更关系的数据以何种方式去传输,是需要可靠传输呢,还是不可靠传输,都需要根据情况而定.</p>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写点简单的装饰器</title>
      <link href="/2017/12/28/%E5%86%99%E7%82%B9%E7%AE%80%E5%8D%95%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2017/12/28/%E5%86%99%E7%82%B9%E7%AE%80%E5%8D%95%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>一个计算函数运行时间的装饰器:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cal_func</span><span class="params">(*args, **kargs)</span>:</span></span><br><span class="line">        start = datetime.datetime.now()</span><br><span class="line">        result = func(*args, **kargs)</span><br><span class="line">        end = datetime.datetime.now()</span><br><span class="line">        print(<span class="string">'cost_time:'</span>, (end - start).microseconds)</span><br><span class="line">    <span class="keyword">return</span> cal_func</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@cal_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span></span><br></pre></td></tr></table></figure><p>在访问网页时判断用户是否登陆:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.core.urlresolvers <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> user.models <span class="keyword">import</span> Users</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_login</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_login</span><span class="params">(request)</span>:</span></span><br><span class="line">        <span class="comment"># 如果登陆,返回函数func</span></span><br><span class="line">        ticket = request.COOKIES.get(<span class="string">'ticket'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ticket:</span><br><span class="line">            <span class="comment"># 没有登陆,跳转到登陆页面</span></span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'user:login'</span>))</span><br><span class="line">        user = Users.objects.filter(ticket=ticket)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'user:login'</span>))</span><br><span class="line">        <span class="keyword">return</span> func(request)</span><br><span class="line">    <span class="keyword">return</span> check_login</span><br></pre></td></tr></table></figure><p>这里是使用的ticket来模拟session id,没有使用Django自带的request.session,通过判断请求中的seesion id是否存在以及与session是否一致来判断用户是否登陆,可以放在需要登陆才能访问的视图函数之前.</p><p>在Django中实现判断用户是否登陆还可以中间件来实现,方法多样.</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对内置装饰器的理解</title>
      <link href="/2017/12/21/%E5%AF%B9%E5%86%85%E7%BD%AE%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2017/12/21/%E5%AF%B9%E5%86%85%E7%BD%AE%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>装饰器就是用函数来包装函数,对内函数赋予一些我们所需要的功能,Python有三个内置的装饰器:staticmethod,classmethod和property,这三个装饰器都是和类相关的.</p><h3 id="staticmethond"><a href="#staticmethond" class="headerlink" title="@staticmethond"></a>@staticmethond</h3><p>一般情况,要使用类的方法,需要先实例化一个对象再调用方法,使用staticmethod(静态方法)之后,可以直接使用类来进行方法的访问,不需要事先进行实例化,这样做的好处就是可以将属于这个类的函数放到静态方法中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">class_arr = <span class="number">1</span></span><br><span class="line"><span class="comment"># 对象方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态方法</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">'B'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化对象</span></span><br><span class="line">foo = test()</span><br><span class="line">foo.A()</span><br><span class="line">foo.B()</span><br><span class="line">test.B()</span><br><span class="line">test.A()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">B</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"C:\Users\29427\Desktop\reivew.py"</span>, line <span class="number">36</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    test.A()</span><br><span class="line">TypeError: A() missing <span class="number">1</span> required positional argument: <span class="string">'self'</span></span><br></pre></td></tr></table></figure><p>可以看出,使用静态方法装饰的方法,类可以直接访问,而没有被装饰的方法,类是无法访问的,并且装饰的方法是不用传入self的</p><h3 id="classmethod"><a href="#classmethod" class="headerlink" title="@classmethod"></a>@classmethod</h3><p>类方法和静态方法很相似,区别在于静态方法装饰的方法是不需要传入self的,而类方法装饰的方法是需要传入一个隐式的对象作为参数,这个隐式的对象在有继承时表示相应的子类,在无继承时表示当前类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">staticSayHello</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"Parent static"</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">classSayHello</span><span class="params">(cls)</span>:</span>  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cls == Boy:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"Boy classSayHello"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> cls == Girl:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"girl sayHello"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span><span class="params">(Parent)</span>:</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span><span class="params">(Parent)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Boy.classSayHello()</span><br><span class="line">Girl.classSayHello()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boy classSayHello</span><br><span class="line">girl sayHello</span><br></pre></td></tr></table></figure><p>可以看出这个隐式的类参数可以进行类的区分</p><h3 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h3><p>该装饰器可以将方法变成属性,在进行访问时就不能像访问方法那样进行访问,要用访问属性的方式进行访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'分数必须是整数才行呐'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'分数必须0-100之间'</span>)</span><br><span class="line">        self._score = value</span><br><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">60</span> </span><br><span class="line">s.set_score(<span class="number">60</span>)</span><br><span class="line">s.score </span><br><span class="line">s.get_score()</span><br></pre></td></tr></table></figure><p>使用property来装饰score时会自动创建一个新的setter装饰器,使用setter可以对属性进行赋值,这样做的话,对一个属性的查询和修改就会简单很多.</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>亲爱的Python，你为什么这么难看？</title>
      <link href="/2017/12/20/%E4%BA%B2%E7%88%B1%E7%9A%84Python%EF%BC%8C%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E9%9A%BE%E7%9C%8B%EF%BC%9F/"/>
      <url>/2017/12/20/%E4%BA%B2%E7%88%B1%E7%9A%84Python%EF%BC%8C%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E9%9A%BE%E7%9C%8B%EF%BC%9F/</url>
      <content type="html"><![CDATA[<h1 id="Dear-Python-Why-Are-You-So-Ugly"><a href="#Dear-Python-Why-Are-You-So-Ugly" class="headerlink" title="Dear Python, Why Are You So Ugly?"></a>Dear Python, Why Are You So Ugly?</h1><p><em>by</em> <a href="http://www.grokcode.com/about/" target="_blank" rel="noopener">Jess Johnson</a> in <a href="http://www.grokcode.com/category/archives/programming-languages/" target="_blank" rel="noopener">Programming Languages</a></p><p>Dear Python, something has been bothering me for a while. Its just that, well, ummm…you’re kind of ugly. Look, you are beautiful inside: Python is a beautiful language and the Python community is open and welcoming. But Python resources are ugly enough to affect usability and adoption. This is damaging to the community.</p><p>Documentation and tutorials are often difficult to navigate. Products built with Python don’t put any thought into design. Blogging software written in Python helps create more ugly blogs about Python. Pythonistas just don’t care about presentation.</p><p>Let’s compare the usability and design of some different Python and Ruby sites. Ruby is a good reference point since it occupies a similar niche in the programming language ecosystem and is roughly the same age.</p><p><a href="http://www.learnpython.org/" target="_blank" rel="noopener"><img src="./learn-python-tutorial.png" alt="Python Interactive Tutorial"></a><a href="http://tryruby.org/" target="_blank" rel="noopener"><img src="./ruby-tutorial-Code-School-TryRuby.png" alt="Ruby Interactive Tutorial"></a></p><p>Above are online interactive tutorials for learning Python vs. Ruby. Learnpython.org isn’t ugly exactly, it’s just that Try Ruby is so much more polished. It’s obvious that a professional designer had a hand in Try Ruby, whereas the design of learnpython.org was thrown together by a programmer who later slapped a few ads on it and called it done. Which tutorial would you rather use?</p><p><a href="https://www.djangoproject.com/" target="_blank" rel="noopener"><img src="./django-framework2.png" alt="Django web framework"></a><a href="http://rubyonrails.org/" target="_blank" rel="noopener"><img src="./ruby-on-rails-framework1.png" alt="Ruby on Rails web framework"></a></p><p>Here are the homepages for Django and Ruby on Rails, popular web frameworks. Django’s homepage is poorly organized. The entire page is just a mess of links with no clear emphasis on anything. In contrast, the Ruby on Rails homepage does a good job of introducing people to Rails and pointing them to different areas of the site.</p><p><a href="http://www.holovaty.com/" target="_blank" rel="noopener"><img src="./Adrian-Holovaty.png" alt="Adrian Holovaty&#39;s Homepage"></a><a href="http://david.heinemeierhansson.com/" target="_blank" rel="noopener"><img src="./David-Heinemeier-Hansson.png" alt="David Heinemeier Hansson&#39;s Homepage"></a></p><p>Homepage of Django co-creator Adrian Holovaty vs. Ruby on Rails creator David Heinemeier Hansson. Both are well organized, but it is obvious at a glance who places importance on professional design and who doesn’t.</p><p><a href="https://developers.google.com/appengine/" target="_blank" rel="noopener"><img src="./Google-App-Engine.png" alt="Google App Engine hosting"></a></p><p><img src=".\Heroku-Cloud-Application-Platform .png" alt=""></p><p>Cloud hosting: Google App Engine vs. Heroku. Once again the Ruby side is sexier.</p><p><a href="http://www.blogofile.com/" target="_blank" rel="noopener"><img src="./Blogofile.png" alt="Blogofile blogging software"></a><a href="http://jekyllrb.com/" target="_blank" rel="noopener"><img src="./jekyll.png" alt="Jekyll blogging software"></a></p><p><a href="http://tinkerer.bitbucket.org/" target="_blank" rel="noopener"><img src="./tinkerer.png" alt="Tinkerer Python blogging software"></a><a href="http://octopress.org/" target="_blank" rel="noopener"><img src="./Octopress.png" alt="Octopress Ruby blogging software"></a></p><p>Python blogging software vs Ruby blogging software. The Python blog designs are uninspiring and unpolished, while the Ruby designs are striking. And who doesn’t love octopodes?</p><p><a href="http://www.egenix.com/" target="_blank" rel="noopener"><img src="./egenix1.png" alt="eGenix Python consulting"></a><a href="http://norbauerinc.com/" target="_blank" rel="noopener"><img src="./ruby-on-rails-consulting.png" alt="Norbauerinc ruby consulting"></a></p><p><a href="http://www.tummy.com/Services/Consulting/python.html" target="_blank" rel="noopener"><img src="./tummy.png" alt="Tummy Python consulting"></a><a href="http://littlelines.com/" target="_blank" rel="noopener"><img src="./littlelines.png" alt="Littlelines Ruby consulting"></a></p><p>Some top Google search results for “python consulting” vs. “ruby consulting”. The Python results look painfully outdated.</p><p>Maybe Ruby has an advantage because it is more tightly focused on web programming? It seems likely that consultants for web apps would have nicer web pages than consultants working on, say, scientific problems. To eliminate any unfair advantage, below are some top Google search results for “django consulting” vs. “ruby on rails consulting”.</p><p><a href="http://www.fezconsulting.com/" target="_blank" rel="noopener"><img src="./fez-consulting.png" alt="Fez Django consulting"></a><a href="http://integrumtech.com/" target="_blank" rel="noopener"><img src="./scrum-and-agile-coaching.png" alt="Scrum and agile rails consulting"></a></p><p>It doesn’t matter. Python is still the ugly duckling.</p><p>This wasn’t a scientific comparison – somebody could try show the opposite conclusion by cherry-picking a different set of sites – but I think the screenshots I used are pretty representative. I also think that most people who have spent a little bit of time in both communities will agree that Python sites <em>are</em> ugly compared to Ruby sites.</p><h2 id="Why-does-this-happen"><a href="#Why-does-this-happen" class="headerlink" title="Why does this happen?"></a>Why does this happen?</h2><p>Either Pythonistas aren’t pairing with designers as often as Rubyists, Pythonistas have less design talent, or Pythonistas simply don’t care enough about design to spend the time to do it right. I’m not really sure which is the case.</p><h2 id="Does-it-matter"><a href="#Does-it-matter" class="headerlink" title="Does it matter?"></a>Does it matter?</h2><p>Yes! This stuff matters.</p><p>It’s not just that Python sites are ugly (even though they are). It’s that the uglyness makes sites hard to navigate and hard to use. It’s that nobody is inspired by uglyness and nobody wants to use ugly products when there are better options. Nobody wants to hire someone who builds ugly web apps. It is unprofessional and sloppy to be so ugly.</p><p>This damages the Python community.</p><p>这是外国程序员把Python相关站点和Ruby相关站点的UI对比,Python基本完败,感觉就像把一个出生在60年代的老年人和一个出生在21世纪的青年人穿衣风格做对比,上次去访问scipy的官网,我是真的搞不懂,一个做人工智能数据分析的公司页面会这么丑,难道他们就真的要把程序员的那种风格表现出来吗?</p>]]></content>
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life,Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>事不过三,三则重构</title>
      <link href="/2017/12/15/%E4%BA%8B%E4%B8%8D%E8%BF%87%E4%B8%89-%E4%B8%89%E5%88%99%E9%87%8D%E6%9E%84/"/>
      <url>/2017/12/15/%E4%BA%8B%E4%B8%8D%E8%BF%87%E4%B8%89-%E4%B8%89%E5%88%99%E9%87%8D%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>如果一个功能在代码中出现次数超过三次,就需要将该功能封装起来在需要的地方调用,及时闻到代码的坏味道是成为一名优秀程序员的必备技能.</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django自带的一整套登陆注册权限角色</title>
      <link href="/2017/12/10/Django%E8%87%AA%E5%B8%A6%E7%9A%84%E4%B8%80%E6%95%B4%E5%A5%97%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%E6%9D%83%E9%99%90%E8%A7%92%E8%89%B2/"/>
      <url>/2017/12/10/Django%E8%87%AA%E5%B8%A6%E7%9A%84%E4%B8%80%E6%95%B4%E5%A5%97%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%E6%9D%83%E9%99%90%E8%A7%92%E8%89%B2/</url>
      <content type="html"><![CDATA[<p>在写登陆注册时,一般有两种方法,一种是直接使用Django的auth模块,另外一种就是自己模拟实现session和session id,前者的弊端就是字段固定,需要扩展时需要进行重写,后者就是自己造轮子,费时费力,设计的可能并没有Django那么好,但是可以精确控制字段,扩展度高,就来说说auth模块吧.</p><h3 id="User"><a href="#User" class="headerlink" title="User"></a>User</h3><p>User是auth模块中维护用户信息的关系模式,在数据库中被命名为auth_user,使用migrate会自动生成.</p><p>创建User表的SQL语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &quot;auth_user&quot; (</span><br><span class="line">    &quot;id&quot; integer NOT NULL PRIMARY KEY AUTOINCREMENT, </span><br><span class="line">    &quot;password&quot; varchar(128) NOT NULL, &quot;last_login&quot; datetime NULL, </span><br><span class="line">    &quot;is_superuser&quot; bool NOT NULL, </span><br><span class="line">    &quot;first_name&quot; varchar(30) NOT NULL, </span><br><span class="line">    &quot;last_name&quot; varchar(30) NOT NULL,</span><br><span class="line">    &quot;email&quot; varchar(254) NOT NULL, </span><br><span class="line">    &quot;is_staff&quot; bool NOT NULL, </span><br><span class="line">    &quot;is_active&quot; bool NOT NULL,</span><br><span class="line">    &quot;date_joined&quot; datetime NOT NULL,</span><br><span class="line">    &quot;username&quot; varchar(30) NOT NULL UNIQUE</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在导入该时需要这样写,需要区别时是自带的还是自己写的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br></pre></td></tr></table></figure><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user = User.objects.create_user(username, password)</span><br><span class="line">user.save()</span><br></pre></td></tr></table></figure><p>这里就是和普通ORM操作有所区别,通常使用了create之后就不需要.save就可以保存,这里需要执行.save来进行保存,auth模块会自动加密我们的密码.如果不用自带的User,需要加密解密时时就要用到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加密</span></span><br><span class="line">make_password()</span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">check_password()</span><br></pre></td></tr></table></figure><h3 id="认证用户"><a href="#认证用户" class="headerlink" title="认证用户"></a>认证用户</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate</span><br><span class="line">user = authenticate(username=username, password=password)</span><br></pre></td></tr></table></figure><p>认证成功返回True,认证失败返回Flase,一般在登陆时使用.</p><h3 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.set_password(new_password)</span><br><span class="line">user.save()</span><br></pre></td></tr></table></figure><p>这样可以配合中间件验证是否登陆,登陆的话可以进行修改密码.</p><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> login</span><br><span class="line"><span class="comment"># 验证用户信息</span></span><br><span class="line">user = authenticate(username=username, password=password)</span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">   <span class="comment"># 登陆</span></span><br><span class="line">   login(request, user)</span><br></pre></td></tr></table></figure><p>使用login登陆成功之后,会设置session中的值,对用户进行跟踪,这里需要注意的是,没有使用login模块来进行登陆的话就需要使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.session[<span class="string">'xxx'</span>] = xxx</span><br></pre></td></tr></table></figure><h3 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> logout</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    logout(request)</span><br></pre></td></tr></table></figure><p>如果不适用logout来尽心注销,就需要使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> request.sessionp[<span class="string">'xxx]</span></span><br></pre></td></tr></table></figure><p>来删除session</p><p>这只是Django中模块的冰山一角,其中还有很多它帮我们造好的轮子,比如权限判断,限制登陆才能访问等.</p>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django反向建模</title>
      <link href="/2017/12/03/Django%E5%8F%8D%E5%90%91%E5%BB%BA%E6%A8%A1/"/>
      <url>/2017/12/03/Django%E5%8F%8D%E5%90%91%E5%BB%BA%E6%A8%A1/</url>
      <content type="html"><![CDATA[<h3 id="从model到数据库的正向迁移"><a href="#从model到数据库的正向迁移" class="headerlink" title="从model到数据库的正向迁移"></a>从model到数据库的正向迁移</h3><p>通过model然后使用makemigrations可以将模型中的类迁移到数据库,一个类就对应一张表,这种方式也是建立数据库最快速的方法,但是有一个弊端就是会添加一些Django自带的表,很多时候并不需要这些自带表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将数据添加到缓存</span></span><br><span class="line">python manage.py makemigrations</span><br><span class="line"><span class="comment"># 添加到数据库</span></span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><h3 id="从数据库到model的反向建模"><a href="#从数据库到model的反向建模" class="headerlink" title="从数据库到model的反向建模"></a>从数据库到model的反向建模</h3><p>使用powerdesigner创建数据库模型,它基本支持目前所有的关系型数据库,提供了企业级的建模和设计解决方案,需要注意的是powerdesigner中设置主键为自增需要手动设置,并不是默认行为.</p><p><img src=".\designer.png" alt=""></p><p>通过逻辑模型然后生成物理模型然后生成sql语句就可以在相应的数据库中创建数据,当有了这些数据之后,可以将数据库中中表在Django的模型中生成相应的class</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py inspectdb &gt; user/model.py</span><br></pre></td></tr></table></figure><p>通过上述语句,就可以将连接的数据库中的数据在模型中生成相应的class.</p>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>不仅仅在视图中的反向查询</title>
      <link href="/2017/11/30/%E4%B8%8D%E4%BB%85%E4%BB%85%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%90%91%E6%9F%A5%E8%AF%A2/"/>
      <url>/2017/11/30/%E4%B8%8D%E4%BB%85%E4%BB%85%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%90%91%E6%9F%A5%E8%AF%A2/</url>
      <content type="html"><![CDATA[<p>以往使用Django提供的ORM功能都是通过在视图操作模型来实现数据库的增删改查,在这个过程中,带有外键约束的那一方为正方,正方关联的那一方为反方,通过外键去访问关联对象就是正向查询,而不带外键的那一方去访问关联对象就是反向查询,当然这些都是很基本的开发技能.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    text = models.TextField(default=<span class="string">''</span>)</span><br><span class="line">    list = models.ForeignKey(List, default=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正向查询</span></span><br><span class="line">item = Item.objects.all().first()</span><br><span class="line">list_ = item.list.title</span><br><span class="line"><span class="comment"># 反向查询</span></span><br><span class="line">list_ = List.objeacts.get(id=<span class="number">1</span>)</span><br><span class="line">item = list_.item_set.all()</span><br></pre></td></tr></table></figure><p>这种查询不仅仅可以在视图中进行,Django的模板引擎让我可以在模板中同样能够进行ORM操作,不仅仅局限在view当中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> item <span class="keyword">in</span> list.item_set.all %&#125;           </span><br><span class="line">    &#123;&#123; item.text &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>这样大大提高的查询数据的灵活性,不把ORM操作局限在某一块地方.</p>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>替换回调函数</title>
      <link href="/2017/11/25/%E6%9B%BF%E6%8D%A2%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
      <url>/2017/11/25/%E6%9B%BF%E6%8D%A2%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>使用re.sub来进行复杂的字符串替换时,只能将某一个或某几个字符替换称一样的字符串例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">'UPPER PYTHON, lower python, Mixed Python'</span></span><br><span class="line">res = re.sub(<span class="string">'python'</span>, <span class="string">'snake'</span>, text, flags=re.IGNORECASE)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPPER snake, lower snake, Mixed snake</span><br></pre></td></tr></table></figure><p>可以看到,替换的字符串并没有按照以前的大小写顺序来进行替换,都被统一替换成了snake,如果需要按照以前的大小写的顺序来替换的话,就需要使用到替换回掉函数,如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">text = <span class="string">'UPPER PYTHON, lower python, Mixed Python'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matchcase</span><span class="params">(word)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replace</span><span class="params">(m)</span>:</span></span><br><span class="line">        text = m.group()</span><br><span class="line">        <span class="keyword">if</span> text.isupper():</span><br><span class="line">            <span class="keyword">return</span> word.upper()</span><br><span class="line">        <span class="keyword">elif</span> text.islower():</span><br><span class="line">            <span class="keyword">return</span> word.lower()</span><br><span class="line">        <span class="keyword">elif</span> text[<span class="number">0</span>].isupper():</span><br><span class="line">            <span class="keyword">return</span> word.capitalize()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> word</span><br><span class="line">    <span class="keyword">return</span> replace</span><br><span class="line"></span><br><span class="line">res = re.sub(<span class="string">'python'</span>, matchcase(<span class="string">'snake'</span>), text, flags=re.IGNORECASE)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><p>函数replace是我们的替换回调函数,输入的参数是一个匹配对象,由match()或find()返回,我们可以从debug中看出其工作流程</p><p><img src=".\tihuanhuidiao.png" alt="tihuanhuidiao"></p><p>它会将匹配的对象依次去进行大小写的对比,然后再进行替换并返回正确的替换结果.</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>区分通配符与正则表达式</title>
      <link href="/2017/11/19/%E5%8C%BA%E5%88%86%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2017/11/19/%E5%8C%BA%E5%88%86%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>通配符在Linux中遇见的比较多,CSS里面也有,而正则表达式范围就更广了,相比于通配符也更复杂,这两者中使用了一些相同的符号来实现匹配,但是同样的符号意义却不一样,在Python中通配符和正则也处于不同的模块中.</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则的概念也不用我多说,基本每个程序员都会使用到,我说说这里面几个和通配符一样的符号,并对他们的意义作出区别,使用markdown有些符号不能单独打出,我居然发现这里面还可以使用转义字符,神奇.</p><p>*:匹配前面的子表达式0次或者n次(n∈(0,∞)),属于贪婪匹配,例如fo*,能匹配到fo,foo等,等同于fo{0,}</p><p>?:匹配前面的子表达式0次或者1次,例如li(ke)?,能匹配到li,like,等同于{0,1}</p><p>[]:匹配一个指定范围的字符,例如[ab]cd,可以匹配到acd,bcd</p><p>{}:指定匹配子表达式的个数,有三种形式{n},{n,},{n,m}.</p><p>python中使用正则表达式需要导入的模块是re</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符一般在shell中使用,功能和正则表达式相比要弱很多,一般只用于文件名匹配,匹配方法有点介于简单的字符串方法和全功能的正则表达式之间.</p><p>可以在简单的数据处理中使用,注意区别符号的含义</p><p>*:星号代替0个,单个,多个字符,可以单独使用,例如*.py,可以匹配到所有后缀为.py的文件.</p><p>?:问号代替一个字符,可以单独使用,例如typor?,可以匹配到typora等文件.</p><p>python中要使用通配符需要导入的模块是fnmatch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fnmatch <span class="keyword">import</span> fnmatchcase</span><br><span class="line">result_1 = fnmatchcase(<span class="string">'test.py'</span>, <span class="string">'*.py'</span>)</span><br><span class="line">result_2 = fnmatchcase(<span class="string">'test.py'</span>, <span class="string">'tes?.py'</span>)</span><br><span class="line">print(result_1)</span><br><span class="line">print(result_2)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>通过比较可以看出,正则中的*和?是无法单独存在,必须和子表达式同时出现作为一个匹配的规则,而通配符中的*和?是可以单独存在的代替一个或多个字符.</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux,Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>筛选爬取的url的几种方法</title>
      <link href="/2017/11/11/%E7%AD%9B%E9%80%89%E7%88%AC%E5%8F%96%E7%9A%84url%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2017/11/11/%E7%AD%9B%E9%80%89%E7%88%AC%E5%8F%96%E7%9A%84url%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>最近学习爬虫去获取淘宝页面中每个商品的url时,得到的信息中有很多无用的url,所以就想使用一些方法将这些无用的url筛选掉.</p><p>比如我需要获取的url必须是http和https开头的,至少有三种方法可以帮助我去获得所需信息.</p><p>首先是str.startswith()和str.endswith()方法,爬虫获取的url一般是以数组来呈现的,所以在使用这两个方法之前需要先处理一下,并且还有一个坑的地方是传入的判断条件如果是列表形式的话,会出现报错,改成元组之后就没问题.</p><p>传入列表出现报错:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = [<span class="string">'http://wwww.baidu.com'</span>, <span class="string">'t.taobao.com'</span>]</span><br><span class="line">need_url = [i <span class="keyword">for</span> i <span class="keyword">in</span> url <span class="keyword">if</span> i.startswith([<span class="string">'http'</span>, <span class="string">'https'</span>])]</span><br><span class="line">print(need_url)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: startswith first arg must be str <span class="keyword">or</span> a tuple of str, <span class="keyword">not</span> list</span><br></pre></td></tr></table></figure><p>传入元组:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = [<span class="string">'http://wwww.baidu.com'</span>, <span class="string">'t.taobao.com'</span>]</span><br><span class="line">need_url = [i <span class="keyword">for</span> i <span class="keyword">in</span> url <span class="keyword">if</span> i.startswith((<span class="string">'http'</span>, <span class="string">'https'</span>))]</span><br><span class="line">print(need_url)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'http://wwww.baidu.com'</span>]</span><br></pre></td></tr></table></figure><p>这样就可以筛选出所需的url.</p><p>除了str.startswith()和str.endswith()以后,还可以通过切片和正则表达式的方式来判断获取的url,但是这两种方法相比上述的方法就有杀鸡焉用牛刀的感觉,而且也不是那么的优雅.</p><p>使用字符串的切片:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = [<span class="string">'http://wwww.baidu.com'</span>, <span class="string">'t.taobao.com'</span>]</span><br><span class="line">need_url = [i <span class="keyword">for</span> i <span class="keyword">in</span> url <span class="keyword">if</span> (i[:<span class="number">5</span>] == <span class="string">'https'</span> <span class="keyword">or</span> i[:<span class="number">4</span>] == <span class="string">'http'</span>)]</span><br><span class="line">print(need_url)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'http://wwww.baidu.com'</span>]</span><br></pre></td></tr></table></figure><p>这种方法我感觉太笨重,给人一种很死的感觉.</p><p>使用re来完成匹配:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">url = [<span class="string">'http://wwww.baidu.com'</span>, <span class="string">'t.taobao.com'</span>, <span class="string">'https://www.taobao.com'</span>]</span><br><span class="line">need_info = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> url:</span><br><span class="line"><span class="keyword">if</span> re.match(<span class="string">r'http|https'</span>, i):</span><br><span class="line">need_info.append(i)</span><br><span class="line">print(need_info)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'http://wwww.baidu.com'</span>, <span class="string">'https://www.taobao.com'</span>]</span><br></pre></td></tr></table></figure><p>哇,很简单的两句就能写完的,我居然写了8句,感觉有点像让一个高中生去做小学生的题一样,小学生想的简单做的就简单,高中生想的复杂写的复杂.</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>字典使用ChainMap与update的区别</title>
      <link href="/2017/11/05/%E5%AD%97%E5%85%B8%E4%BD%BF%E7%94%A8ChainMap%E4%B8%8Eupdate%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2017/11/05/%E5%AD%97%E5%85%B8%E4%BD%BF%E7%94%A8ChainMap%E4%B8%8Eupdate%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>ChainMap提供了一种从逻辑上将不同的字典或者映射合并为一个单独的映射,而字典中自带的update方法也可以字典合并,通过比较这种不同的方法,可以在不同的场合选用不同的方法来进行映射的处理.</p><p>ChainMap:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">a = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;</span><br><span class="line">b = &#123;<span class="string">'z'</span>: <span class="number">3</span>, <span class="string">'w'</span>: <span class="number">4</span>, <span class="string">'x'</span>: <span class="number">5</span>&#125;</span><br><span class="line">c = ChainMap(a, b)</span><br><span class="line">print(c)</span><br><span class="line">a[<span class="string">'x'</span>] = <span class="number">10</span></span><br><span class="line">b[<span class="string">'z'</span>] = <span class="number">10</span></span><br><span class="line">print(c)</span><br><span class="line">print(c[<span class="string">'x'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ChainMap(&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'z'</span>: <span class="number">3</span>, <span class="string">'w'</span>: <span class="number">4</span>, <span class="string">'x'</span>: <span class="number">5</span>&#125;)</span><br><span class="line">ChainMap(&#123;<span class="string">'x'</span>: <span class="number">10</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'z'</span>: <span class="number">10</span>, <span class="string">'w'</span>: <span class="number">4</span>, <span class="string">'x'</span>: <span class="number">5</span>&#125;)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>可以看到,合并后的字典中的值是与原始字典联系在一起的,原始字典改变合并后的字典也会同时变化,并且当两个原始字典中有重复的键时,ChainMap会默认现在第一个字典中的值,当然合并后的ChainMap对象支持所有的字典的操作.</p><p>update:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;</span><br><span class="line">b = &#123;<span class="string">'z'</span>: <span class="number">3</span>, <span class="string">'w'</span>: <span class="number">4</span>, <span class="string">'x'</span>: <span class="number">5</span>&#125;</span><br><span class="line">c = a</span><br><span class="line">c.update(b)</span><br><span class="line">print(c)</span><br><span class="line">a[<span class="string">'y'</span>] = <span class="number">10</span></span><br><span class="line">b[<span class="string">'w'</span>] = <span class="number">10</span></span><br><span class="line">print(c)</span><br><span class="line">print(c[<span class="string">'x'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'x'</span>: <span class="number">5</span>, <span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">3</span>, <span class="string">'w'</span>: <span class="number">4</span>&#125;</span><br><span class="line">&#123;<span class="string">'x'</span>: <span class="number">5</span>, <span class="string">'y'</span>: <span class="number">10</span>, <span class="string">'z'</span>: <span class="number">3</span>, <span class="string">'w'</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>从上述代码可以看出,字典的update方法是在原始字典的基础上进行合并的,更准确的说,这应该是将一个字典按照另外一个字典进行更新,相同的键会更新为后一个字典中的值,并后一个字典在之后的进行更改后并不会影响合并后的字典.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>区别:</p><ol><li>ChainMap合并后的新字典键值对改变不会影响原字典,而update是在一个字典的基础的进行合并,破坏了原始字典.</li><li>ChainMap产生的字典对象中的键值会随原始字典的变化而变化,update更新后的字典就是原始字典,与参考更新的字典没有任何关系.</li><li>遇到相同的键,ChainMap总是将第一个字典的这个键的值作为合并后字典的值,而update刚好相反,它会采用后一个字典的值</li></ol>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web开发第一道难关</title>
      <link href="/2017/11/01/Web%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E9%81%93%E9%9A%BE%E5%85%B3/"/>
      <url>/2017/11/01/Web%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E9%81%93%E9%9A%BE%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>cookie和session对我来说并不陌生,以前读书的时候开电脑的第一件事就是打开360清理垃圾,里面有一栏会提示是否清除cookie,当时我并不知道这玩意用来干嘛,随意基本都是每次都会清除.</p><p>最近在写登陆注册,遇到了cookie的session,并不是很理解,百度百科讲有太过于专业,看着很难理解,百度了很久结合了很多答案,再加上自己的理解,来记录一下以便好对比对错.</p><h3 id="Session的概念"><a href="#Session的概念" class="headerlink" title="Session的概念"></a>Session的概念</h3><p>Session存放于服务器端用于存放用户信息,当用户第一次发送请求时,服务器会自动生成一个Session和Session ID用来记录这个用户,并在响应中附带这个Session ID返回到浏览器.</p><p>当用户第二次去请求服务器时.在请求中就会附带这个Session ID,服务器在获取这个ID后就会去数据库中对比Session,从而获取到用户的信息.</p><p>浏览器中保存这个Session ID有多种方式,但是我只遇到过使用cookie来保存所以就暂时说明这种方式:</p><p>服务器将Session ID发送到浏览器后.cookie将这个ID保存,如果不设置过期期限的话,当用户关闭浏览器后,就会自动清除这个ID,如果设置了过期期限,这个cookie就会保存到硬盘中,以便下次读取.</p><h3 id="Cookie的概念"><a href="#Cookie的概念" class="headerlink" title="Cookie的概念"></a>Cookie的概念</h3><p>可以称之为’浏览器缓存’,它是在Web服务器保存在浏览器上的小文本文件,用于保存信息,但是保存的信息大小不能超过4K.</p><h3 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h3><p>cookie是存储在浏览器上,而session是保存在服务器上的,当我们访问服务器时,会将cookie中存储的session ID取出发往服务器,然后再根据这个ID查询相应的session从而获取用户信息.cookie一般用于判断用户是否登陆,以便下次能够直接登陆,还有就是能够保存我们浏览购物网站放入购物车的商品的信息还有一些搜索信息.</p><p>session是存储于服务器上的,所以无法伪造,而cookie是存在于本地的,所以可以被伪造,从安全性的角度来说,sessio是安全的,而cookie是不安全的.session一般用于验证登陆信息,存储一些私人或者比较重要的信息.</p><h3 id="Cookie与Sesssion的联系"><a href="#Cookie与Sesssion的联系" class="headerlink" title="Cookie与Sesssion的联系"></a>Cookie与Sesssion的联系</h3><p>Cookie属于Session对象的一种,Session ID的存储依赖于Cookie.</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Postman模拟发送POST请求403问题</title>
      <link href="/2017/10/26/Postman%E6%A8%A1%E6%8B%9F%E5%8F%91%E9%80%81POST%E8%AF%B7%E6%B1%82403%E9%97%AE%E9%A2%98/"/>
      <url>/2017/10/26/Postman%E6%A8%A1%E6%8B%9F%E5%8F%91%E9%80%81POST%E8%AF%B7%E6%B1%82403%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最近在写登陆注册时用到Postman来模拟提交表单,因为Django自带的CSRF保护机制,需要在所有的POST请求中附带上csrftoken,所以进行模拟发送POST请求时会一直显示403错误,并且在控制台中也会显示下面错误提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Forbidden (CSRF token missing <span class="keyword">or</span> incorrect.)</span><br></pre></td></tr></table></figure><p>经过测试,发现只有通过浏览器去访问Django服务器时才会获取到这个’csrftoken’,如果Django站点只提供API而没有页面的话,就没有办法使用这个保护机制.</p><p>只是为了前期的测试,可以注释掉settings.py中的中间键来取消这个验证</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 'django.middleware.csrf.CsrfViewMiddleware',</span></span><br></pre></td></tr></table></figure><p>这样看来,开发一个纯提供API的服务器,使用Django是无法提供安全保护的,需要使用其他途径来实现保护.</p>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基本数据类型的推导式</title>
      <link href="/2017/10/17/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8E%A8%E5%AF%BC%E5%BC%8F/"/>
      <url>/2017/10/17/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8E%A8%E5%AF%BC%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>处理序列中的数据时,比如提取其中的值或者根据某种标准来对序列做删减或替换使用推导式就非常方便.</p><p>列表推导式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取列表中大于0和小于0的数,返回的结果也要是列表</span></span><br><span class="line">info = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>]</span><br><span class="line">need_info = [i <span class="keyword">for</span> i <span class="keyword">in</span> info <span class="keyword">if</span> i &gt; <span class="number">0</span>]</span><br><span class="line">need_info2 = [i <span class="keyword">for</span> i <span class="keyword">in</span> info <span class="keyword">if</span> i &lt; <span class="number">0</span>]</span><br><span class="line">print(need_info)</span><br><span class="line">print(need_info2)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>]</span><br></pre></td></tr></table></figure><p>如果先去遍历然后再重组就把代码写的繁琐,使用列表推导式去完成筛选,就显得干净利落.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将不符合条件的元素替换,返回的结果也得是列表</span></span><br><span class="line">info = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>]</span><br><span class="line"><span class="comment"># 将小于0的数替换成0</span></span><br><span class="line">need_info = [i <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> info]</span><br><span class="line">print(need_info)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>我真的想不出还有比这更方便快速的方法了.</p><p>字典推导式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取股价大于200的公司</span></span><br><span class="line">price = &#123;</span><br><span class="line">    <span class="string">'ACME'</span>: <span class="number">45.23</span>,</span><br><span class="line">    <span class="string">'AAPL'</span>: <span class="number">612.78</span>,</span><br><span class="line">    <span class="string">'IBM'</span>: <span class="number">205.55</span>,</span><br><span class="line">    <span class="string">'HPQ'</span>: <span class="number">37.20</span>,</span><br><span class="line">    <span class="string">'FB'</span>: <span class="number">10.75</span></span><br><span class="line">&#125;</span><br><span class="line">com = &#123;key:value <span class="keyword">for</span> key, value <span class="keyword">in</span> price.items() <span class="keyword">if</span> value &gt; <span class="number">200</span>&#125;</span><br><span class="line">print(com)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'AAPL'</span>: <span class="number">612.78</span>, <span class="string">'IBM'</span>: <span class="number">205.55</span>&#125;</span><br></pre></td></tr></table></figure><p>除了字典和列表推导式,还有元组推导式以及利用生成器来筛选数据,如果考虑到性能的话,还需要对其他指标进行计算,不管性能如何,至少从书写方式上,也不会去选择写法繁琐的方式去实现想要的功能,</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安利一本有趣的书</title>
      <link href="/2017/10/05/%E5%AE%89%E5%88%A9%E4%B8%80%E6%9C%AC%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B9%A6/"/>
      <url>/2017/10/05/%E5%AE%89%E5%88%A9%E4%B8%80%E6%9C%AC%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B9%A6/</url>
      <content type="html"><![CDATA[<p>最近喜欢上了Python cookbook这本书,看到一些很科幻的模块感觉像打开了新世界的大门,虽然不太懂模块的底层是如何实现功能,但是能够顺手用起来也是一件不错的事情.</p><p>喜欢这本书的另外一个原因是,我再也不会因为看书看着看着就睡着了,我随时都要思考如何去使用其中介绍的语法,如何才能把这些东西用到我的工作中,就算有些方法暂时还用不到,但作为无聊时的消遣也是不错的选择.</p><p>它从基本的数据结构讲到面向对象再到高并发到最后的C扩展,基本囊括了初级工程师到中级工程师所需的所有技能,如果熟读这本书,调戏一下面试官也不是不可能的.</p><p>因为时间被挤的太多了,但是抽空去看看这本书收获还是很大的,我觉得把其中一些觉得有用的方法记录下来是必要的,将别人的知识变成自己的知识本身就是初级编程者必须的技能.</p><p>另外,吐槽一下kindel用起来真的不怎么样,电子书再怎么方便,我还是想回归最本质的读书方式,电子书也挺贵的,我不如买书.</p>]]></content>
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>序列中元素个数的计算</title>
      <link href="/2017/09/30/%E5%BA%8F%E5%88%97%E4%B8%AD%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
      <url>/2017/09/30/%E5%BA%8F%E5%88%97%E4%B8%AD%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
      <content type="html"><![CDATA[<p>在需要计算一个序列中的每个元素的出现的次数时,就拿最常见的列表来说,如果只通过列表中提供的count方法来计算某个元素出现的次数很难将元素和次数组合在一起.</p><p>在collections提供的Counter类就很好的解决了这一类问题,来看看它是如何实现元素的计数,并将元素与个数对应起来的吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line">counter = Counter(a)</span><br><span class="line">top = counter.most_common(<span class="number">1</span>) <span class="comment"># counter的实例调用most_common方法可以实现计算序列中前多少数量的元素</span></span><br><span class="line">detail_info = counter[<span class="string">'a'</span>] <span class="comment"># 可以单独查询某个元素出现的次数,和list.count效果相同</span></span><br><span class="line">print(counter)</span><br><span class="line">print(top)</span><br><span class="line">print(detail_info)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">1</span>&#125;)</span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>可以看到Counter对象将元素与个数很好的对应起来了,需要注意的是作为Counter参数的序列元素必须要可哈希的,不然是无法处理的.</p><p>值得注意的是Counter对象还可以与数学运算结合起来,如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line">b = [<span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'g'</span>, <span class="string">'z'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>]</span><br><span class="line">counter1 = Counter(a)</span><br><span class="line">counter2 = Counter(b)</span><br><span class="line">add = counter1 + counter2</span><br><span class="line">sub = counter1 - counter2</span><br><span class="line">print(add)</span><br><span class="line">print(sub)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">6</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>, <span class="string">'g'</span>: <span class="number">1</span>, <span class="string">'z'</span>: <span class="number">1</span>&#125;)</span><br><span class="line">Counter(&#123;<span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>加法可以将两个不同的对象相结合起来,但是如果是减法两个对象中都没有的元素进行相减不会有任何结果也没有输出.</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>序列的去重</title>
      <link href="/2017/09/24/%E5%BA%8F%E5%88%97%E7%9A%84%E5%8E%BB%E9%87%8D/"/>
      <url>/2017/09/24/%E5%BA%8F%E5%88%97%E7%9A%84%E5%8E%BB%E9%87%8D/</url>
      <content type="html"><![CDATA[<p>对所获取的的数据进行去重显得尤为重要,爬虫获取的冗余数据在大多时候都是都是无效且占用空间的.</p><p>设想有两个场景,一个是去除序列中出现的重复元素,获得的新序列是无序的,另外一个是去重获得新序列之后,依然是按照处理之前的顺序进行排列的.</p><p>无论是哪两种情况,序列的去重都是围绕set集合展开的,当然这也是set比较重要的属性.</p><p>对于第一种情况,直接使用set来处理就尤为简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">a = set(a)</span><br><span class="line">a = list(a)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>可以看到输出的结果并不是按照原始顺序排列的,但依然有个问题就是转换后序列是按照升序排列的,最后测试一下,发现数据量较大时是不会出现这种情况的,集合并没有自动排序的功能.</p><p>对于第二种情况,想要去重并且顺序不发生改变,这里又有两种情况,一种是序列元素是可哈希的,另外一种是序列元素不可哈希的.</p><p>可哈希对象表示的是,在它生存期内是不可变的,如整数,浮点数,字符串,元组等.</p><p>对于可哈希元素:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge</span><span class="params">(items)</span>:</span></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">            seen.add(item)</span><br><span class="line">b = list(judge(a))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>使用这种方法,可以实现不打乱顺序产生序列.</p><p>对于不可哈希元素:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [&#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'y'</span>:<span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'y'</span>:<span class="number">3</span>&#125;, &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'y'</span>:<span class="number">2</span>&#125;]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judge</span><span class="params">(items, key=None)</span>:</span></span><br><span class="line">seen = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        val = item <span class="keyword">if</span> key <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">else</span> key(item)</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">            seen.add(val)</span><br><span class="line">b = list(judge(a, key = <span class="keyword">lambda</span> key:(key[<span class="string">'x'</span>], key[<span class="string">'y'</span>])))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;]</span><br></pre></td></tr></table></figure><p>如果容器中的元素为不可哈希元素时,需要使用这种方法来进行去重才能保证保持元素的顺序,这种方法同时也可以实现容器中元素为可哈希的情况.</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>QuerySet与QueryDict</title>
      <link href="/2017/09/17/QuerySet%E4%B8%8EQueryDict/"/>
      <url>/2017/09/17/QuerySet%E4%B8%8EQueryDict/</url>
      <content type="html"><![CDATA[<p>QuerySet,本质上是一个给定的模型的对象列表,虽然名字中带有set,刚开始会让我觉得其性质应该和集合有些许联系,但是就像Java和javascript那样,就是彻彻底底两种不同的语言,为什么说他是对象列表而不是像其名字那样的集合呢,因为它是有序的,并且表现形式上也更像是一个列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;QuerySet [&lt;Cus: Cus object&gt;, &lt;Cus: Cus object&gt;]&gt;</span><br></pre></td></tr></table></figure><p>对于QuerySet最为神奇的就是,可以将返回的QuerySet链起来形成一串连续的查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Book.objects.filter(year_published__gt=1990) \</span><br><span class="line">            .exclude(author=&apos;Richard Dawkins&apos;) \</span><br><span class="line">            .order_by(&apos;author&apos;, &apos;-year_published&apos;)</span><br></pre></td></tr></table></figure><p>并且也可以像列表那样,通过index去获取所需的第几条信息,当然使用遍历去获取其中的每一条信息也是没问题的.</p><p>QueryDict是HttpRequest获取的对象,GET和POST属性是django.http.QuertDict类的实例,数据结构类似于字典,以键值对的形式存在,但是和字典最大的区别就是,QueryDict允许存在相同的键.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;info&apos;:[&apos;zsb&apos;, 111]&#125;</span><br></pre></td></tr></table></figure><p>QueryDict中数据获取方式可以像字典那种使用dict[‘info’]或者dict.get(‘info’),不过需要注意的是,如果存在一键对于多值,使用get只会获得最后一个值,如果想要获取所有的值就需要使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict.getlist(&apos;info&apos;)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简单但有效的csrf_token</title>
      <link href="/2017/09/10/%E7%AE%80%E5%8D%95%E4%BD%86%E6%9C%89%E6%95%88%E7%9A%84csrf-token/"/>
      <url>/2017/09/10/%E7%AE%80%E5%8D%95%E4%BD%86%E6%9C%89%E6%95%88%E7%9A%84csrf-token/</url>
      <content type="html"><![CDATA[<p>在说起表单提交发起POST请求之前,我需要聊一聊CSRF(跨站请求伪造),当然百度上一大堆CSRF的概念,我就用找到的一张图来说明这个概念吧.</p><p><img src=".\csrf.jpg" alt=""></p><p>所以Django为我们提供了一种用来防御它的非常容易使用的系统,简而言之,就是每次使用POST请求时都应该使用{ % csrf_token % }来避免CSRF.</p><p>知道这个防护原理也是必要的:</p><p>在用户访问django的可信站点时，django反馈给用户的表单中有一个隐含字段csrftoken，这个值是在服务器端随机生成的，每一次提交表单都会生成不同的值。当用户提交django的表单时，服务器校验这个表单的csrftoken是否和自己保存的一致，来判断用户的合法性。当用户被csrf攻击从其他站点发送精心编制的攻击请求时，由于其他站点不可能知道隐藏的csrftoken字段的信息这样在服务器端就会校验失败，攻击被成功防御，这样就能避免被 CSRF 攻击。</p>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模板中的过滤器</title>
      <link href="/2017/08/28/%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2017/08/28/%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>之前在模板中处理从视图接口中获得的数据时没有遇到过时间格式的数据,最近遇到在处理这种从Mysql中获得的时间格式数据时,发现放在模板中页面上呈现的格式有点问题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zsb:July 10, 1994</span><br><span class="line">cjh:July 26, 1994</span><br></pre></td></tr></table></figure><p>这种格式对于用户来说体验肯定是不好的,所以得修改成可读的格式,然后就发现了过滤器这块新大陆.</p><p>过滤器的主要作用就是在页面呈现之前对数据进行修改,符号是’|’,功能应该和Linux中管道的用法类似,因为符号相同,所以就联想到那里去了,过滤器中提供了很多帮助程序员处理数据的语法,我就归纳了几个看起来常用的方法,如果以后遇到了其他的继续补充就是了.</p><p>加减法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; stu.stu_yuwen | add:10 &#125;&#125;</span><br><span class="line">&#123;&#123; stu.stu_yuwen | add:-10 &#125;&#125;</span><br></pre></td></tr></table></figure><p>因为计算机不会使用减号进行减法,记得是哪位老师上课的时候讲的,所以计算机进行减法计算的时候就是加上一个负数来实现减法,所以这里使用过滤器实现减法就是把add:10换成add:-10就OK了.</p><p>修改大小写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; stu.stu_name | upper &#125;&#125;</span><br><span class="line">&#123;&#123; stu.stu_name | lower &#125;&#125;</span><br></pre></td></tr></table></figure><p>实用场景还暂时没遇到,那就先记住吧.</p><p>修改时间格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; stu.stu_birth | date:&apos;Y-m-d&apos;  &#125;&#125;</span><br><span class="line">&#123;&#123; stu.stu_birth | date:&apos;Y-m-d H:m:s&apos;  &#125;&#125;</span><br></pre></td></tr></table></figure><p>修改后:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1994-07-10</span><br></pre></td></tr></table></figure><p>这里使用Y表示的是四位的年份,使用y是显示两位的年份,使用M,D显示的是英文的月和日,使用H表示的是24小时制,使用h表示的是12小时制.</p>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模板中不同注释语句的用法</title>
      <link href="/2017/08/24/%E6%A8%A1%E6%9D%BF%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%B3%A8%E9%87%8A%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2017/08/24/%E6%A8%A1%E6%9D%BF%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%B3%A8%E9%87%8A%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="html中的注释"><a href="#html中的注释" class="headerlink" title="html中的注释"></a>html中的注释</h3><p>Djanog模板中的html我遇到过的两种注释,一种形式是&lt; !– – &gt;,另外一种是{ #  # },刚开始并不清楚这两种的用法,所以用起来就很混乱,所以决定把所有的注释给归纳一下.</p><p>使用&lt; !– – &gt;来进行注释,被注释的语句或者语法从页面上是已经无法看见的,但是如果查看网页源码,依然可以从源码中看到被注释的内容.</p><p>这是html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是内容 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &#123;% for i in customer %&#125; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &#123;&#123; i.u_name &#125;&#125; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &#123;% endfor %&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是源码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是内容 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- zsb --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- cjh --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出,不光是被注释的内容在源码中显示出来了,被注释的语法也依然运行成功,在源码中显示出了结果.</p><p>使用{ #  # }来进行注释的话,就相对注释的更彻底,在页面和网页源码中都不会出现被注释的内容,只有维护的程序员才能看到这种注释.</p><p>这是html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;# 这是内容 #&#125;</span><br><span class="line">&#123;#&#123;% for i in customer %&#125;#&#125;</span><br><span class="line">&#123;#    &#123;&#123; i.u_name &#125;&#125;#&#125;</span><br><span class="line">&#123;# &#123;% endfor %&#125;#&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是源码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出,所有被注释的内容都不会被查看到,无论是页面还是源码中</p><p>我还是习惯性的ctrl + /来进行注释,使用{ #  # }对我来说,可以防止产生一些不必要的错误.</p><p>另外,查阅资料发现Django模板中还提供了第三种注释方式,刚才两种都是单行注释,使用 { % comment % } </p><p>{ % endcomment % } 能够进行多行注释,这种注释和{ #  # }效果是一样的.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% comment %&#125;</span><br><span class="line">&#123;% for i in customer %&#125;</span><br><span class="line">    &#123;&#123; i.u_name &#125;&#125;</span><br><span class="line"> &#123;% endfor %&#125;</span><br><span class="line">&#123;% endcomment %&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS中的注释"><a href="#CSS中的注释" class="headerlink" title="CSS中的注释"></a>CSS中的注释</h3><p>因为html中会放入CSS和JS,所以会产生一种错觉,这三个东西使用的注释应该是同一种注释.</p><p>事实肯定不是我想的那样,CSS中的注释使用的是</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*font-weight: 100;*/</span></span><br><span class="line"><span class="comment">/*这是一条注释*/</span></span><br></pre></td></tr></table></figure><p>使用该方法来添加我们的注释或者注释掉一些暂时不需要的代码</p><h3 id="JS中的注释"><a href="#JS中的注释" class="headerlink" title="JS中的注释"></a>JS中的注释</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(data);</span></span><br><span class="line"><span class="comment">// 这是一条注释</span></span><br></pre></td></tr></table></figure><p>使用//来添加代码的注释或者注释掉一些暂时不需要的代码</p><p>所以总结一下,HTML中注释有两种,一种是可执行的注释&lt; !– – &gt;,一种是不可执行的注释{ #  # },CSS中的注释是/**/,JS中的注释是//.</p>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模板的继承</title>
      <link href="/2017/08/20/%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
      <url>/2017/08/20/%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<p>模板的继承主要好处就是将重复出现的代码加载在父模板中,后续的子模版直接继承可以简化页面布局.</p><p>父模板:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">        &#123;% block title %&#125;</span><br><span class="line">            &#123;# 这是标题 #&#125;</span><br><span class="line">        &#123;% endblock %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    &#123;% block extCSS %&#125;</span><br><span class="line">        &#123;# 这是样式表 #&#125;</span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;% block top %&#125;</span><br><span class="line">    &#123;# 这是网页头部  #&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &#123;# 这是网页内容 #&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">&#123;% block bottom %&#125;</span><br><span class="line">    &#123;# 这是网页底部 #&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">&#123;% block extJS %&#125;</span><br><span class="line">    &#123;# 这是js #&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子模版:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends 'base.html' %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% block title %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% block extCSS %&#125;</span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block extJS %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>模板的继承需要注意的是:</p><ol><li><p>子模版继承父模板后,子模版原先的内容就不会显示,只能继承或者重写父模板中的block模块.</p></li><li><p>子模版会继承父模板所有的block模块,如果不进行重写就会显示父模板block中的内容.</p></li></ol>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>无题</title>
      <link href="/2017/08/16/%E6%97%A0%E9%A2%98/"/>
      <url>/2017/08/16/%E6%97%A0%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>我希望有一天能像你一样,读上世界最好的大学,也希望你能在大洋彼岸乘风破浪.</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>全局设置中路径的配置</title>
      <link href="/2017/08/01/%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE%E4%B8%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/08/01/%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE%E4%B8%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>在settings.py文件中进行模板,静态文件等的路径配置刚开始把我给绕晕了,以前没有接触到路径这一块时总感觉绝对路径多么多么好,简洁明了一眼就能看出是哪个盘哪个文件,最后发现只有windos系统才有盘符,其他系统都没有这个玩意,还有反斜杠,瞬间觉得微软才是异类.</p><p>在settings.py中BASE_DIR代表当前根目录文件的路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br></pre></td></tr></table></figure><p>刚开始的连续的三个os.path真的把我吓住了,一眼看上去真的很复杂,然后我从里层从外层打印,分清了os.path.abspath和os.path.dirname的区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\<span class="number">29427</span>\Desktop\sub_py</span><br><span class="line">C:\Users\<span class="number">29427</span>\Desktop\sub_py\test_path.py</span><br><span class="line">C:\Users\<span class="number">29427</span>\Desktop</span><br><span class="line">C:\Users\<span class="number">29427</span></span><br><span class="line">C:\Users\<span class="number">29427</span>\Desktop</span><br></pre></td></tr></table></figure><p>所以abspath是获得该文件的绝对路径包括文件名,dirname是获得该文件的绝对路径不包括文件名.</p><p>由上可以得出,BASE_DIR可以用下述代码进行替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(__file__))</span><br></pre></td></tr></table></figure><p>在全局配置中的BASE_DIR最后得到的路径就是项目根目录的路径,将这个路径与template,media,static文件夹相拼接,就得到了相应所需的路径,比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br><span class="line">STATICFILES_DIRS = os.path.join(BASE_DIR, STATIC_URL)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>F对象和Q对象</title>
      <link href="/2017/07/26/F%E5%AF%B9%E8%B1%A1%E5%92%8CQ%E5%AF%B9%E8%B1%A1/"/>
      <url>/2017/07/26/F%E5%AF%B9%E8%B1%A1%E5%92%8CQ%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>要从数据库中查找满足某种对比条件的样本时,会使用到Django中自带的F对象,但是需要手动导入这个模块.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gra = Grade.objects.filter(g_name=<span class="string">'python'</span>).first()</span><br><span class="line">stu = gra.stu_set.filter(stu_yuwen__gte=F(<span class="string">'stu_shuxue'</span>))</span><br></pre></td></tr></table></figure><p>查询一个班级中语文成绩大于等于数学成绩的学生,需要知道的是如果是直接比较而不通过F对象的话,会直接出现小红线报错.</p><p>如果我要去查询同时满足多个条件的样本时,有两种方法,一种是直接用逗号分割条件,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gra = Grade.objects.filter(g_name=<span class="string">'python'</span>).first()</span><br><span class="line">stu = </span><br><span class="line">gra.stu_set.filter(stu_yuwen__gte=<span class="number">80</span>, stu_sex=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>另外一种是使用Q查询对象,该对象不仅提供了’与’的运算,同时还支持’或’,’非’运算,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gra = Grade.objects.filter(g_name=<span class="string">'python'</span>).first()</span><br><span class="line">stu = </span><br><span class="line">gra.stu_set.filter(Q(stu_yuwen__gte=<span class="number">80</span>) &amp; Q(stu_sex=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>查询一个班级中语文成绩大于等于80并且性别为女生的样本,Q对象提供了&amp;,|,~三种逻辑运算,所以可以很方便进行筛选查找,同样也需要手动导入.</p><p>也可以同时在一条查询语句中同时使用这两种对象,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gra = Grade.objects.filter(g_name=<span class="string">'python'</span>).first()</span><br><span class="line">stu = gra.stu_set.filter(Q(stu_yuwen__gte=F(<span class="string">'stu_shuxue'</span>) + <span class="number">10</span>) &amp; Q(stu_sex=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>查询一个语文成绩大于等于数学成绩加10分并且性别是男生的样本.</p>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>时间与空间的矛盾</title>
      <link href="/2017/07/21/%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E7%9A%84%E7%9F%9B%E7%9B%BE/"/>
      <url>/2017/07/21/%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E7%9A%84%E7%9F%9B%E7%9B%BE/</url>
      <content type="html"><![CDATA[<p>记得以前上软件技术导论的时候,听的最多的话就是时间和空间是两个不可调和的矛盾,要么去拥有时间,要么去拥有空间,当然如果一个算法中即不节省空间,也不节约空间,那这就是个失败的算法.</p><p>这两者是不可同时兼得的,就拿Python中的数据类型来说</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">list_ = []</span><br><span class="line">tupel_ = ()</span><br><span class="line">dic_ = &#123;&#125;</span><br><span class="line">set_ = set([])</span><br><span class="line">print(<span class="string">'%s,%s'</span> % (type(list_), sys.getsizeof(list_)))</span><br><span class="line">print(<span class="string">'%s,%s'</span> % (type(tupel_), sys.getsizeof(tupel_)))</span><br><span class="line">print(<span class="string">'%s,%s'</span> % (type(dic_), sys.getsizeof(dic_)))</span><br><span class="line">print(<span class="string">'%s,%s'</span> % (type(set_), sys.getsizeof(set_)))</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;class 'list'&gt;,64</span><br><span class="line">&lt;class 'tuple'&gt;,48</span><br><span class="line">&lt;class 'tuple'&gt;,240</span><br><span class="line">&lt;class 'set'&gt;,224</span><br></pre></td></tr></table></figure><p>可以看到,列表和元组所占内存较小,而字典和集合占的内存较大,所以可以这样理解,当我们去查询某一个元素是否在列表或者字典中时,列表查找的时间复杂度是O(n),而字典查找的时间复杂度是O(1),字典牺牲了空间换取了时间.</p><p>我只是很肤浅的从这里看到了一点关于时间与空间的矛盾,我相信通过不断的深入学习,应该会遇到更多的这种情况.</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python中基本的数据结构</title>
      <link href="/2017/07/20/Python%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2017/07/20/Python%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>我并没有系统的学过数据结构,顶多也就是自己买了本严蔚敏的数据结构看了一下,所以在遇到一些这方面问题就是真的头大,今天看书时发现了Python中collentions.OrderedDict这个模块中有一种内部维持双向链路的有序字典对象,就忽然想去学习一下顺序表,链表的知识.</p><p>Python中有有序和无序的数据类型,像set,dict是无序的,而list,tuple是有序的.首先集合和字典是基于哈希表实现,对于这两个类型的理解,我认为集合就是只有键没有值的字典,因为翻阅了下资料,发现Python在最开始时是并没有set这个概念的,最早的set雏形就是{‘a’:None, ‘b’:None}这种字典.还有一个更为奇怪的是,字典本身是无序的,但是使用IDE去输出打印时总会按照我赋值的顺序输出字典,我只能归咎于IDE帮我处理了这个字典,在内存中,这个字典每一组键值对的排列都不是按照我赋值的顺序存储的.</p><p>对于有序的list和tuple来说,它们是由顺序表实现的,元组和列表最大的区别有两个,一是元组是不可变类型,即不变的顺序表,它不支持任何改变其内部状态的操作,而列表刚好相反,列表被定义为动态的顺序表,也就是说我可以对其进行appent,inset,pop等操作,另外一个区别是元组是可以去重的,而列表是可以允许有重复元素的.</p><p>由于在创建一个顺序表时,需要预先知道数据大小来申请连续的存储空间,而在进行扩充时又会使用copy来开辟一段新的内存空间,所有使用起来并不是很灵活,所以为了充分利用计算机内存空间,实现灵活的动态管理,就得使用到链表.</p><p>链表也是一种线性表,但是并不是连续的存储数据,而是每一个节点里存放下一个节点的位置信息,每个节点包含两个域.一个是信息域(用来存放数据),一个是链接域(用来查找下一个节点).</p><p><img src=".\lianbiao.jpg" alt=""></p><p>单向链路:</p><p><img src=".\Singlylinkedlist.jpg" alt=""></p><p>双向链路:</p><p><img src=".\doublelinkedlist.jpg" alt=""></p><p>单向链路只能通过前一个节点查找后一节点并且不可逆,双向链路是可逆的,除此之外还有单向循环链路和双向循环链路,也就是tail的地址不再指向None而是head的地址.</p><p>但是需要明确的是,链路只是灵活的使用了内存,但付出的代价是增加了地址字段,开销增大,所以说并没有什么完美的算法能够保证又节约时间,又节省空间.</p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python,数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django通过Model查找数据遇到的问题</title>
      <link href="/2017/07/16/Django%E9%80%9A%E8%BF%87Model%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017/07/16/Django%E9%80%9A%E8%BF%87Model%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>我先建立了一个学生与学生信息的一对一关系模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    stu_name = models.CharField(max_length=<span class="number">6</span>, unique=<span class="keyword">True</span>)</span><br><span class="line">    stu_sex = models.BooleanField(default=<span class="number">0</span>)</span><br><span class="line">    stu_birth = models.DateField()</span><br><span class="line">   </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table= <span class="string">'stu'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StuInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    stu_addr = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    stu_age = models.IntegerField()</span><br><span class="line">    stu = models.OneToOneField(Stu)</span><br><span class="line">    </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'stu_info'</span></span><br></pre></td></tr></table></figure><p>我根据学生去查找学生信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stu = Stu.objects.all().first()</span><br><span class="line">stu_info = stu.StuInfo</span><br><span class="line">print(stu_info.stu_addr)</span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">'show_stu.html'</span>)</span><br></pre></td></tr></table></figure><p>我想在调用url时,在控制台打印出我查询的数据,然后就出现报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception Value:</span><br><span class="line"><span class="string">'Stu'</span> object has no attribute <span class="string">'StuInfo'</span></span><br></pre></td></tr></table></figure><p>我通过对象去点上模型名,这样没问题啊,为什么会显示没有这个属性呢?</p><p>折腾了一下,发现把表名改为小写就可以查询了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu_info = stu.stuinfo</span><br></pre></td></tr></table></figure><p>所以说在数据库查询的时候,不管是一对一还是多对多,点上表名的时候都得用小写.</p><p>如果对于某些有强迫症的人,就必须要用表名去查询数据的话,可以使用这个来指定查询的相对名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">    default_related_name = <span class="string">'StuInfo'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django简介</title>
      <link href="/2017/07/15/Djanogo%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/07/15/Djanogo%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h3 id="Django介绍"><a href="#Django介绍" class="headerlink" title="Django介绍:"></a>Django介绍:</h3><p>Django是一个开放源代码的Web应用框架，由Python写成。采用了MVC的框架模式，即模型M，视图V和控制器C。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。</p><p>要是以后我能发明一种框架,我一定要用自己的名字来命名,以免我被淹没在历史的洪流里.</p><p>在学习Django的时候和一些搞Java开发的同学聊过几次,他们经常抱怨外包到华为天天写控制器,当时我挺羡慕的,控制器多高端啊,其实现在想起来我应该是忽略了天天这两个字,但是学了之后也没那么高端,至少没有Python的scipy那几个模块高端.</p><h3 id="师从MVC"><a href="#师从MVC" class="headerlink" title="师从MVC:"></a>师从MVC:</h3><p>Django的框架模式从本质来说依然是经典的MVC,就来看看MVC这个Web开发大佬是如果运作的.</p><p>我就按照自己的理解来说一下这个moderl-view-controller,即模型-视图-控制器</p><p>Model: 这一块是直接与数据库相关的,也就是模型对象负责在数据库中存取数据</p><p>View: 这一块负责数据的显示和呈现,数据呢,肯定是从model那里来的,数据展示在哪里?通过html页面来进行展示,不过现在应该不仅限于html.</p><p>Controller: 这一块负责人机交互,从用户端收集用户的输入,进行业务逻辑处理.</p><p>模式图奉上:</p><p><img src=".\mvc.jpg" alt=""></p><p>核心思想: 将输入,处理,输出分开,即解耦</p><h3 id="不逊色的MVT"><a href="#不逊色的MVT" class="headerlink" title="不逊色的MVT:"></a>不逊色的MVT:</h3><p>我喜欢称Django的框架模式为变异的MVC,但归根结底也是继承于MVC,我本来就对控制器不是太了解,要是我精通Java就好了,这下好了,Django直接就没有控制器这一说法.</p><p>Moder-View-Template,即模型-视图-模板,从字面上感觉像是用模板来替代了控制器,但并不是</p><p>Model: 作用与MVC的model一样,负责与数据库的连接,进行数据的存取</p><p>View: Django的View活动范围就有点广,他首先负责业务逻辑,然后还要调用Moder和Template,它并不像MVC的视图那样为用户呈现数据.</p><p>Template: 模板的功能与MVC的视图一样,负责进行页面的渲染展示给用户</p><p>Django还有个特别的url分发器,作用和路由器差不多,所有也称之为路由,作用是通过页面传回的url来调用合适的view.</p>]]></content>
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>这不仅仅是一个开始</title>
      <link href="/2017/07/14/%E8%BF%99%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BC%80%E5%A7%8B/"/>
      <url>/2017/07/14/%E8%BF%99%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>我想所有的编程语言都是以善意的问候世界开始它们独特魅力的吧,我也记不清楚我用了几种语言在控制台输出Hello,World,我只知道在我学习单片机的时候抱怨C语言指针太难看不懂,也记得学习立志学习Java却在中途发现Python的输出打印如此简洁转而跑去学习Python.</p><p>在学习Python后我没有太多接触其他语言,一方面是因为害怕遇到语法更美丽,书写更简洁的语言又放弃Python,另一方面想拜读的那位导师建议我去学Python,虽然最后没有机会成为他的学生.</p><p>我考研报考的是大数据方向,其实在本科大多数都是在和硬件打交道,对于大数据也只是经常看见新闻吹的玄乎玄乎的,所以我就想去考,当时院长也说川大的计算机学院还是很厉害的,还说我上了复试线可以帮我找个好导师,到最后我去参加复试,院长却退休了,真的悲伤.</p><p>无论是什么语言,我都觉得这仅仅是一种工具,一种用来表现人类行为的工具,最为重要的是如何使用这门语言来模拟我们的行为并且来实现它.</p><p>昨天我为我的Python之路好好规划了一下,首先肯定是最常见的Web开发,然后是爬虫,数据分析,大数据,虽然不清楚在到第几个阶段我会跑去读书,但肯定的是书是一定要读的,我总不能被女朋友文凭一直给压着吧.</p><p>那就从今天开始吧,我上有老但不需要我养,我爸那天还说以后工作了别让他们倒贴就万事大吉,无奈.我下又无小,何不轻装前行?</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/06/01/hello-world/"/>
      <url>/2017/06/01/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>MySQL主从配置</title>
      <link href="/2017/01/14/MySQL%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/01/14/MySQL%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>MySQL的主从配置比redis的主从相比要轻松的多,可能我参与的比较少吧,但是基本的主从配置还是没有问题的.</p><h3 id="主配置"><a href="#主配置" class="headerlink" title="主配置"></a>主配置</h3><p>主从主要实现的是读写分离,这样做法的优势有很多,我所理解的一个是缓解服务器的读写压力.</p><p>在Ubuntu下,配置文件为my.cnf,位置为/etc/mysql/my.cnf</p><p>在windows下,配置文件为my.ini</p><p>vim my.cnf # 进入配置文件进行设定</p><p>server-id=200 # 设置主服务器的ID,主和从的id号不能相同</p><p>innodb_flush_log_at_trx_commit=2 # 防止断电数据丢失</p><p>sync_binlog=1 # 开启binlog日志同步功能</p><p>log-bin=mysql-bin-200 # binlog日志文件名</p><p>binlog-do-db=xxx # 这个表示同步哪个库,不写的话表示同步所有的库</p><h3 id="主配置完成后-重启主库"><a href="#主配置完成后-重启主库" class="headerlink" title="主配置完成后,重启主库"></a>主配置完成后,重启主库</h3><p>service mysql restart</p><p>mysql -uroot -p # 登陆</p><p>grant replication slave on . to ‘‘mark‘@’192.168.1.201’ identified by ‘123456’; # 授权给从数据库服务器192.168.1.201, 用户名mark, 密码123456</p><p>show master status; # 查看主库的状态</p><p><img src=".\master_slave.png" alt=""></p><h3 id="从配置"><a href="#从配置" class="headerlink" title="从配置"></a>从配置</h3><p>vim my.cnf</p><p>server-id = 201 # 不能和主ID一样</p><p>innodb_fiush_log_at_trx_commit=2</p><p>sync_binlog=1</p><p>log-bin=mysql-bin-201</p><h3 id="从配置完成后-重启重库"><a href="#从配置完成后-重启重库" class="headerlink" title="从配置完成后,重启重库"></a>从配置完成后,重启重库</h3><p>service mysql restart</p><p>mysql -uroot -p</p><p>change master to master_host=’192.168.1.200’, master_user=’mark’,master_password=’123456’,master_log_file = ‘mysql-bin-200.000002’,master_log_pos=1167; # 这里是建立与主服务器的连接,master_log_pos需要查看主数据库中position的数值</p><p>start slave; # 开启从库</p><p>show slave status; # 查看从数据库状态</p><h3 id="验证主从"><a href="#验证主从" class="headerlink" title="验证主从"></a>验证主从</h3><p>主从中的数据库需要相同,主数据库在进行改动时,从数据库是可以查看的,主数据库负责写,从数据库负责读,分摊数据库压力.</p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL性能优化</title>
      <link href="/2017/01/11/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2017/01/11/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="修改back-log"><a href="#修改back-log" class="headerlink" title="修改back_log"></a>修改back_log</h3><p>back_log值表示MySQL的连接数据达到max_connections时,有多少请求能够被放在堆栈之中以等待其他连接释放.如果等待连接的数量超过back_log时,就不被授予连接资源.</p><p>show variables like ‘back_log’:查看当前数量</p><p>网上说默认值是50, 但是我查出来是80,反正如果要根据当前需求来改变数量,可以在my.ini中将back_log的值修改为500,理论上可以无限增大的,但是会收到系统网卡等的限制.</p><h3 id="修改wait-timeout"><a href="#修改wait-timeout" class="headerlink" title="修改wait_timeout"></a>修改wait_timeout</h3><p>wait_timeout值表示服务器关闭非交互连接之前等待活动的秒数,而interactive_timeout表示的交互式连接等待的秒数,当网站有大量的MySQL连接请求时,设置这个wait_timeout值就非常重要,可以将超时的连接关闭,避免资源的损失.</p><p>将wait_timeout从8小时修改为30分钟,wait_timeout=1800</p><h3 id="修改max-connections"><a href="#修改max-connections" class="headerlink" title="修改max_connections"></a>修改max_connections</h3><p>max_connections指MySQL的最大连接数,在并发连接较大时可以适当增大这个连接数,但是增大连接就意味着更多的内存开销,只能在适当的范围内调节.</p><p>MySQL服务器允许的最大连接数16384</p><p>show variables like ‘max_connections’查看当前连接数</p><p>可以将默认的max_connections值151,修改为3000</p><h3 id="修改max-user-connections"><a href="#修改max-user-connections" class="headerlink" title="修改max_user_connections"></a>修改max_user_connections</h3><p>max_user_connections指同一个账号能够同时连接MySQL服务的最大连接数.</p><p>默认值为0表示不受限制,根据实际需求进行调节.</p><p>要与Max_used_connections的区分开来,后者是表示过去的某段时间最大的连接数.</p><p>show variables like ‘max_user_connections’查看当前值</p><h3 id="修改thread-concurrency"><a href="#修改thread-concurrency" class="headerlink" title="修改thread_concurrency"></a>修改thread_concurrency</h3><p>thread_concurrency指表示开启的线程数,一般根据服务器的CPU核数进行设定,线程数等于CPU x 2</p><p>show variables like ‘thread_concurrency’查看默认值</p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
